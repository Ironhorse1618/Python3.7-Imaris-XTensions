# Filament Sholl Analysis
#
# Written by Matthew J. Gastinger
#
# March 2023 - Imaris 10
#
# ---  Updates:
#   1. Adding a new feature to segment dendrites within each Sholl sphere
#   2. Improving the multi-Filament functionality
#
#
    #<CustomTools>
        #<Menu>
            #<Submenu name="Filaments Functions">
                #<Item name="Filament Sholl Analysis25" icon="Python3">
                    #<Command>Python3XT::XT_MJG_Filament_ShollAnalysis25(%i)</Command>
                #</Item>
            #</Submenu>
       #</Menu>
       #<SurpassTab>
           #<SurpassComponent name="bpFilaments">
               #<Item name="Filament Sholl Analysis25" icon="Python3">
                   #<Command>Python3XT::XT_MJG_Filament_ShollAnalysis25(%i)</Command>
               #</SurpassComponent>
           #</SurpassTab>
    #</CustomTools>


# Description:
#
# Finds and displays Sholl intersections for each Filament that has been traced
# and contains a Starting Point.  Works for both single and multiple filaments.
# Sholl sphere radius is defined by the user.  Each dendrite segments is
# quantified that crosses these intervals at least once.


# RESULTS:
# 1.	 Advanced Sholl Analysis
#         - A Group folder is generated.
#         - Each valid filament will generate a Spots object (named using original FilamentID)
#             and is set with a custom label for each Sholl Radius.
#         -A New Label is generated for each Sholl intersection
#     ---Overall Statistics Tab
#         i.   Critical Radius (um)
#                 ---Sholl distance with the maximum number of intersections from the defined Sholl intervals
#         ii.  Max # Intersections
#                 ---Maximum Number of Intersections at the Critical Radius
#         iii. Critical Radius HighRes (um)
#                 ---Sholl distance with the maximum number of intersections using 1um Sholl Radius
#         iv.  Max # Intersections HighRes
#                 ---Maximum Number of Intersections at the Critical Radius HighRes
#         v.   Dendrite Length Sum
#                   ---Cumulative Sum of all dendrite segments that fall within the
#                     boundaries of the Sholl Spheres (i.e. 10 um Sholl Ring
#                     quantifies dendrites between 0 and 10 um from Starting Point


#         vi.   Regularity Index (Branch and Terminal points)
#                   ---Calculation of Mean Nearest Neighbor based on branch points and terminal points
#                   ---Create a set of Random Spots (10times), same number of branch points or terminal points
#                       ---limit creation of random spots to be within the Convexhull of the filament
#                   ---RegularityIndex is (meanNN)/(meanNN of Random spots)
  #                      ---As R approaches "1" points are closer to a random (Poisson) distribution (as the values of rExperimental and rRandom are more similar).
  #                      ---As R approaches "0" corresponds to dendrites with more clustering (rExperimental < rRandom).
  #                      ---As R greater than '1", nearest neighbors are further apart than it would be expected for a random distribution (rExperimental > rRandom).
#         vii.   Dendritic Field Volume and Dendrite Field Surface area per filament
#                   ---Calculated from convexhull generated by the all terminal points and starting point
#                   ---if 2D, Volume is cross-sectional area
#                   ---if 2D, SurfaceArea is perimeter
#         viii.  Filament - TerminalPoint Mean Distance to soma
#           ix.  Filament - TerminalPoint Max Distance to soma
#            x.  Filament - TerminalPoint Mean Distance along dendrite to soma
#           xi.  Filament - TerminalPoint Max Distance along dendrite to soma
#          xii.  Filament - Dendrite Complexity Index (DCI)
#                   --- DCI = (Sum Terminal branch tip branch depth + Number Terminaal branches) * (Total Filament length(um)/Total Number of primary dendrites)
#                   --- Pillai et al. (2012). PLoS ONE 7(6): e38971. doi:10.1371/journal.pone.0038971
#                   ---

#     ---Detailed Statistics Tab
#         i. Shortest Distance to Starting Point
#                 ---Measures the distance of the Sholl Intersection point to the starting point along the dendrite path
#                         ---Smaller values are closer to the soma
#         ii. Ratio ShollDistance to Distance to Starting Point
#                 ---Values close to “1” correlate highly to Sholl Radius distance
#                 ---Values far from “1” likely possess a non-direct line to soma

# 2.	Sholl Dendrites
#         -A new filament object is created that splits the filament object at each Sholl intersection.
#            --Spilts the the segment by "deleting a single point at Sholl intersection
#             This is primarily used for visualization purposes.
#             ---Each Dendrite is classified and visualized using a
#                 statistics-coded custom statistic for “Sholl Sphere”


# Spine analysis.....UPDATE maybe??
# 1.   nearest neighbor spine along the dendrite (from attachment pt)
#     ----look ony at segment, or extend the cluster to beyond nodes.
# 2.   3,5 ,9 mean nearest neighbors
# 3.   find "clusters" ----maybe place a spot on filament to identify clusters
#     ----maybe use the peak algorithm similar to bouton detection??
# 4.   split number of spines per unit distance from soma (create Label)
#     ----a) in normal sholl sphere
#     ----b) in distance along dendrite.
# 5.   Spine terminal point nearest neighbor
# 6.


# This is not an exact replica of the Sholl intersections reported by the
# Filament object (built into Imaris).  The values are very similar, but the rules
# for identifying a single intersection differ slightly, especially
# around where a branch point intersects a Sholl sphere. (See Readme.doc for
# an report of comparison)


import time
import random
import platform
import math

# GUI imports
# GUI imports
import tkinter as tk
from tkinter import ttk
from tkinter.ttk import *
from tkinter import *
from tkinter import messagebox
from tkinter import simpledialog
from operator import add
from operator import itemgetter
import operator
import itertools
from statistics import mean
from functools import reduce
import collections
#import matplotlib.pyplot as plt


import ImarisLib
# import matplotlib.pyplot as plt
from scipy import stats
from scipy.signal import find_peaks
from scipy.signal import peak_widths
from scipy.spatial.distance import cdist
from scipy.spatial.distance import pdist
from scipy.spatial import Delaunay
from scipy.spatial import ConvexHull

from numpy import array
import numpy as np

aImarisId=0
def XT_MJG_Filament_ShollAnalysis25(aImarisId):
    # Create an ImarisLib object
    vImarisLib = ImarisLib.ImarisLib()
    # Get an imaris object with id aImarisId
    vImarisApplication = vImarisLib.GetApplication(aImarisId)
    # Get the factory
    vFactory = vImarisApplication.GetFactory()
    # Get the currently loaded dataset
    vImage = vImarisApplication.GetDataSet()
    # Get the Surpass scene
    vSurpassScene = vImarisApplication.GetSurpassScene()
    
    vFilaments = vFactory.ToFilaments(vImarisApplication.GetSurpassSelection())
    
    #Create a new folder object for new Sholl Spot intersections
    vNew_Spots = vImarisApplication.GetFactory()
    result2 = vNew_Spots.CreateDataContainer()
    result2.SetName('Sholl Intersections - ' + str(vFilaments.GetName))
    #Old Imaris Version
    aVersionValue = 9.9
    
    ##################################################################
    ##################################################################
    def ShollInput ():
        global vShollRadius,qSplitShollspheres, qOptionTerminalPoints, qOptionBranchPoints
        global qOptionShollDendrites, qOptionMergePoints, qOptionRegularityIndex
        global qOptionConvexHullTerminal, qOptionConvexHull
        qSplitShollspheres=var1.get()
        qOptionBranchPoints = var2.get()
        qOptionTerminalPoints = var3.get()
        qOptionMergePoints = var22.get()
        qOptionShollDendrites = var4.get()
        qOptionRegularityIndex = var5.get()
        qOptionConvexHull = var6.get()
        qOptionConvexHullTerminal = var7.get()
    
    
        vShollRadius=Entry1.get()
        vShollRadius=int(vShollRadius)
        qInputBox.destroy()
    
    qInputBox=Tk()
    qInputBox.title("Advanced Dendrite Analysis")
    qInputBox.geometry("500x460")
    qInputBox.attributes("-topmost", True)
    
    var1 = tk.IntVar(value=0)
    var2 = tk.IntVar(value=0)
    var22 = tk.IntVar(value=1)
    var3 = tk.IntVar(value=0)
    var4 = tk.IntVar(value=0)
    var5 = tk.IntVar(value=0)
    var6 = tk.IntVar(value=0)
    var7 = tk.IntVar(value=0)
    
    
    Label(qInputBox,text="Sholl Sphere Radius (um):").grid(row=0, column=0, sticky=E)
    ##################################################################
    # Set Input Window to center of screen
    # Gets the requested values of the height and widht.
    windowWidth = qInputBox.winfo_reqwidth()
    windowHeight = qInputBox.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(qInputBox.winfo_screenwidth()/2 - windowWidth/2)
    positionDown = int(qInputBox.winfo_screenheight()/2 - windowHeight/2)
    # Positions the window in the center of the page.
    qInputBox.geometry("+{}+{}".format(positionRight, positionDown))
    ##################################################################
    Entry1=Entry(qInputBox,justify='center',width=7)
    Entry1.grid(row=0, column=1, sticky=W)
    Entry1.insert(0, 10)
    
    # tk.Label(qInputBox, text='*Always calculates Sholl').grid(row=0, column=1)
    
    
    
    tk.Checkbutton(qInputBox, text='Create Spots Objects \n'
                   'per Sholl sphere',
                   variable=var1, onvalue=1, offvalue=0).grid(row=2, column=1,)
    tk.Checkbutton(qInputBox, text='Quantify Dendrite Lengths\n'
                                   'per Sholl sphere',
                   variable=var4, onvalue=1, offvalue=0).grid(row=2, column=0, padx=20)
    
    tk.Label(qInputBox, text='____________________________________').grid(row=4, column=0)
    
    tk.Checkbutton(qInputBox, text='Branch Point Analysis',
                   variable=var2, onvalue=1, offvalue=0).grid(row=5, column=0, sticky=W)
    tk.Checkbutton(qInputBox, text='Merge',
                    variable=var22, onvalue=1, offvalue=0).grid(row=5, column=1, sticky=W)
    tk.Checkbutton(qInputBox, text='Terminal Point Analysis',
                   variable=var3, onvalue=1, offvalue=0).grid(row=6, column=0, sticky=W)
    
    tk.Checkbutton(qInputBox, text='Calculate Regularity Index (Terminal/Branch)\n'
                                       '(meanNN/RandomMeanNN)',
                   variable=var5, onvalue=1, offvalue=0).grid(row=7, column=0,sticky=W)
    tk.Label(qInputBox, text='____________________________________').grid(row=8, column=0)
    
    
    
    tk.Checkbutton(qInputBox, text='Create ConvexHull surface (Dendritic Field)',
                   variable=var6, onvalue=1, offvalue=0).grid(row=9, column=0,sticky=W)
    tk.Checkbutton(qInputBox, text='Use Terminal Points',
                   variable=var7, onvalue=1, offvalue=0).grid(row=10, column=0,sticky=W, padx=30)
    
    
    
    qWhatOS = platform.system()
    if qWhatOS == 'Darwin':
        Single=Button(qInputBox, text="Process Sholl Analysis",command=ShollInput )
    else:
        Single=Button(qInputBox, bg="blue", fg="white", text="Process Dendrite Analysis",command=ShollInput )
    Single.grid(row=10, column=1, sticky=W)
    
    tk.Label(qInputBox, text='************************************').grid(row=11, column=0,sticky=W)
    tk.Label(qInputBox, text='--Number Sholl Intersections').grid(row=12, column=0,sticky=W)
    tk.Label(qInputBox, text='--Critical Radius').grid(row=13, column=0,sticky=W)
    tk.Label(qInputBox, text='--Max # Intersections').grid(row=14, column=0,sticky=W)
    tk.Label(qInputBox, text='--Dendrite Length Sum').grid(row=15, column=0,sticky=W)
    tk.Label(qInputBox, text='--Critcal Radius Dendrite Length Sum').grid(row=16, column=0,sticky=W)
    
    tk.Label(qInputBox, text='************************************').grid(row=11, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendritic Field (Volume/Area)').grid(row=12, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendritic Field (SurfaceArea/Perimeter)').grid(row=13, column=1,sticky=W)
    tk.Label(qInputBox, text='--Mean Distance TerminalPoints to Soma').grid(row=14, column=1,sticky=W)
    tk.Label(qInputBox, text='--Max Distance TerminalPoints to Soma').grid(row=15, column=1,sticky=W)
    tk.Label(qInputBox, text='--BranchPoint Classifications').grid(row=16, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendrite Regularity Index (DRI)').grid(row=17, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendrite Complexity Index (DCI)').grid(row=18, column=1,sticky=W)
    
    
    
    
    qInputBox.mainloop()
    ##################################################################
    ##################################################################
    #Create the Progress bars
    #Creating a separate Tkinter qProgressBar for progress bars
    qProgressBar=tk.Tk()
    qProgressBar.title("Sholl Analysis")
    
    # Create a progressbar widget
    progress_bar1 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    progress_bar2 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    progress_bar3 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    # And a label for it
    label_1 = tk.Label(qProgressBar, text="Dendrite ReOrder")
    label_2 = tk.Label(qProgressBar, text="Filament Progress")
    label_3 = tk.Label(qProgressBar, text="Working....")
    
    # Use the grid manager
    label_1.grid(row=0, column=0,pady=10)
    label_2.grid(row=1, column=0,pady=10)
    label_3.grid(row=2, column=0,pady=10)
    
    progress_bar1.grid(row=0, column=1)
    progress_bar2.grid(row=1, column=1)
    progress_bar3.grid(row=2, column=1)
    
    ##################################################################
    # Set Input Window to center of screen
    # Gets the requested values of the height and widht.
    windowWidth = qProgressBar.winfo_reqwidth()
    windowHeight = qProgressBar.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(qProgressBar.winfo_screenwidth()/2 - windowWidth/2)
    positionDown = int(qProgressBar.winfo_screenheight()/2 - windowHeight/2)
    # Positions the window in the center of the page.
    qProgressBar.geometry("+{}+{}".format(positionRight, positionDown))
    ##################################################################
    qProgressBar.geometry('250x130')
    qProgressBar.attributes("-topmost", True)
    
    # Necessary, as the qProgressBar object needs to draw the progressbar widget
    # Otherwise, it will not be visible on the screen
    qProgressBar.update_idletasks()
    progress_bar1['value'] = 0
    qProgressBar.update_idletasks()
    
    start = time.time()
    
    ##################################################################
    ##################################################################
    #Get Image properties
    vDataMin = (vImage.GetExtendMinX(),vImage.GetExtendMinY(),vImage.GetExtendMinZ())
    vDataMax = (vImage.GetExtendMaxX(),vImage.GetExtendMaxY(),vImage.GetExtendMaxZ())
    vDataSize = (vImage.GetSizeX(),vImage.GetSizeY(),vImage.GetSizeZ())
    vSizeT = vImage.GetSizeT()
    vSizeC = vImage.GetSizeC()
    vType = vImage.GetType()
    
    aXvoxelSpacing= (vDataMax[0]-vDataMin[0])/vDataSize[0]
    aYvoxelSpacing= (vDataMax[1]-vDataMin[1])/vDataSize[1]
    aZvoxelSpacing = round((vDataMax[2]-vDataMin[2])/vDataSize[2],3)
    vSmoothingFactor=aXvoxelSpacing*2
    
    #Get the Current Filament Object
    vNumberOfFilaments=vFilaments.GetNumberOfFilaments()
    vFilamentIds= vFilaments.GetIds()
    vFilamentIdsSelected = vFilaments.GetSelectedIds()
    
    
    ################################################
    ################################################
    #Create a new folder object for new Sholl Spot intersections
    # vGroupFolder_ShollSpots = vImarisApplication().GetFactory()
    vShollResult = vImarisApplication.GetFactory().CreateDataContainer()
    vShollResult.SetName('Sholl Intersections per sphere - '+ str(vFilaments.GetName()))
    
    vShollDendrites = vImarisApplication.GetFactory().CreateDataContainer()
    vShollDendrites.SetName('Sholl Dendrites - '+ str(vFilaments.GetName()))
    
    vShollResult2 = vImarisApplication.GetFactory().CreateDataContainer()
    vShollResult2.SetName(' Advanced Dendrite Analysis - '+ str(vFilaments.GetName()))
    
    vSpotFilamentPoints = vImarisApplication.GetFactory().CreateDataContainer()
    vSpotFilamentPoints.SetName(' Dendrite Analysis - '+ str(vFilaments.GetName()))
    
    vSurfaceConvexHull = vImarisApplication.GetFactory().CreateDataContainer()
    vSurfaceConvexHull.SetName(' Dendritic Field Analysis - '+ str(vFilaments.GetName()))
    
    vSurfaceHull = vFactory.CreateSurfaces()
    
    
    ################################################
    ################################################
    vSegmentBranchLength=[]
    wSegmentIdsSpine=[]
    wSegmentIdsDendrite=[]
    wSegmentIdsALL=[]
    
    vSpotPositionAllShollSpheresALL= []
    vSpotPositionAllShollSpheresPerFilamentALL = []
    vNumberofShollIntersectionsALL = []
    vNumberofShollIntersectionsCurrent = []
    vNewStatSpotShollDistanceALL = []
    vNewStatTortuosityPerSegment = []
    
    vSpotPositionAllShollSpheres=[]
    vFilamentCountActual=0
    vSpotPositionAllShollSpheresPerFilament=[]
    vNumberofShollIntersections=[]
    vNewStatSpotShollDistance=[]
    vNewStatNumberShollIntersectionPerFilament=[]
    vNewStatSpotNumberShollIntersections=[]
    vNumberofIntersectionsPerShollSphere=[]
    wCompleteShollSpotDistAlongFilamentStat=[]
    vNumberOfShollIntersectionPerSpherePerFilament=[]
    wCompleteDendriteTimeIndex=[]
    wCompleteFilamentTimeIndex=[]
    vNewStatCompleteFilamentBranchPointDistToSomaMean = []
    vNewStatCompleteFilamentTerminalPointDistToSomaMean = []
    vNewStatCompleteFilamentTerminalPointDistToSomaMax = []
    vNewStatCompleteTortuosityPerSegment = []
    vNewStatCompleteTortuosityPerSegmentSum = []
    vNewStatTortuosityPerFilament = []
    zAllFilamentsRegularityIndexBP = []
    zAllFilamentsRegularityIndexTP = []
    vNodeTypesComplete = []
    wFilamentBranchPointsComplete = []
    wFilamentTerminalPointsComplete = []
    vNodeFilamentIdsComplete = []
    wCompeteSegmentBranchDepthPerFilament = []
    wNewStatConvexHullVolumePerFilament = []
    wNewStatConvexHullAreaPerFilament = []
    wCompleteTerminalPointsDistAlongFilamentStatALL = []
    wCompleteBranchPointsDistAlongFilamentStatALL = []
    wFilamentComplexityIndexComplete = []
    
    
    wLabelListTerminalPoints = []
    wLabelListBranchPoints = []
    
    
    ###############################################################################
    ###############################################################################
    
    zEmptyfilaments=[]
    for aFilamentIndex in range(vNumberOfFilaments):
        vFilamentsRadius = vFilaments.GetRadii(aFilamentIndex)
        if len(vFilamentsRadius)==1:
            zEmptyfilaments.append(int(aFilamentIndex))
    vFilamentIds=[v for i,v in enumerate(vFilamentIds) if i not in zEmptyfilaments]
    
    ###############################################################################
    ###############################################################################
    vAllFilamentDendriteLengthSET = vFilaments.GetStatisticsByName('Segment Length')
    vAllFilamentDendriteLengthIds = vAllFilamentDendriteLengthSET.mIds
    vAllFilamentDendriteLength = vAllFilamentDendriteLengthSET.mValues
    vAllFilamentDendriteBranchDepthSET = vFilaments.GetStatisticsByName('Segment Branch Depth')
    vAllFilamentDendriteBranchDepthIds = vAllFilamentDendriteBranchDepthSET.mIds
    vAllFilamentDendriteBranchDepth = vAllFilamentDendriteBranchDepthSET.mValues
    vAllFilamentLengthSum = vFilaments.GetStatisticsByName('Filament Length (sum)').mValues
    
    vAllFilamentSpineLengthSET = vFilaments.GetStatisticsByName('Spine Length')
    vAllFilamentSpineLengthIds = vAllFilamentSpineLengthSET.mIds
    
    if not vAllFilamentDendriteLengthIds:
        vAllFilamentDendriteLengthSET = vFilaments.GetStatisticsByName('Dendrite Length')
        vAllFilamentDendriteLengthIds = vAllFilamentDendriteLengthSET.mIds
        vAllFilamentDendriteLength = vAllFilamentDendriteLengthSET.mValues
        vAllFilamentDendriteBranchDepthSET = vFilaments.GetStatisticsByName('Dendrite Branch Depth')
        vAllFilamentDendriteBranchDepthIds = vAllFilamentDendriteBranchDepthSET.mIds
        vAllFilamentDendriteBranchDepth = vAllFilamentDendriteBranchDepthSET.mValues
    
    vStatPtPositionXSet = vFilaments.GetStatisticsByName('Pt Position X')
    vStatPtPositionYSet = vFilaments.GetStatisticsByName('Pt Position Y')
    vStatPtPositionZSet = vFilaments.GetStatisticsByName('Pt Position Z')
    vStatPtPosition = []
    vStatPtPosition.append(vStatPtPositionXSet.mValues)
    vStatPtPosition.append(vStatPtPositionYSet.mValues)
    vStatPtPosition.append(vStatPtPositionZSet.mValues)
    
    vStatPtPositionFactors = vStatPtPositionXSet.mFactors
    vStatPtPositionIds =  vStatPtPositionXSet.mIds
    
    wFilamentTerminalPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Terminal')[0].tolist()]
    wFilamentBranchPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Branch')[0].tolist()]
    wFilamentStartingPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Beginning')[0].tolist()]
    wSpineTerminalPtPositionNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Spine Terminal')[0].tolist()]
    wSpineAttachmentPtPositionNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Spine Attachment')[0].tolist()]
    
    if not wFilamentTerminalPointsNEW.any():# == []:
        wFilamentTerminalPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Terminal')[0].tolist()]
        wFilamentBranchPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Branch')[0].tolist()]
        wFilamentStartingPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Beginning')[0].tolist()]
    
    
    ###############################################################################
    ###############################################################################
    #Loop each Filament
    for aFilamentIndex in range(vNumberOfFilaments):
    
        vFilamentsIndexT = vFilaments.GetTimeIndex(aFilamentIndex)
        vFilamentsXYZ = vFilaments.GetPositionsXYZ(aFilamentIndex)
        vFilamentsRadius = vFilaments.GetRadii(aFilamentIndex)
        vFilamentTimepoint = vImage.GetTimePoint(vFilamentsIndexT)
    
    #Test if the time point has empty filament matrix or filament start
    #point and nothing more
        if len(vFilamentsRadius)==1:
            continue
        vFilamentCountActual=vFilamentCountActual+1
        vFilamentsEdgesSegmentId = vFilaments.GetEdgesSegmentId(aFilamentIndex)
    #Find unique values of variable using set, the copnvert back to list
        vSegmentIds=list(set(vFilamentsEdgesSegmentId))
        vNumberOfDendriteBranches = len(vSegmentIds)#total number dendrite segments
        vNumberOfFilamentPoints= len(vFilamentsRadius)#including starting point
        vFilamentTimeIndex=[vFilamentsIndexT]*len(vFilamentsRadius)#for filament spot creation
        vFilamentsEdges = vFilaments.GetEdges(aFilamentIndex)
        vTypes = vFilaments.GetTypes(aFilamentIndex)
        vBeginningVertex = vFilaments.GetBeginningVertexIndex(aFilamentIndex)
        #Test whether filament has a starting point
        if vBeginningVertex==[]:
            continue
        else:
            vBeginningVertexPositionXYZ=vFilamentsXYZ[vBeginningVertex]
        SegmentCountALL=0
        vBranchIndex=0
        #Find in Branch, Terminal and starting point - in current filament
        wFilamentBranchPointsNEWCurrent = np.array(wFilamentBranchPointsNEW)[np.where((wFilamentBranchPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
        wFilamentTerminalPointsNEWCurrent = np.array(wFilamentTerminalPointsNEW)[np.where((wFilamentTerminalPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
        wFilamentStartingPointsNEWCurrent = np.array(wFilamentStartingPointsNEW)[np.where((wFilamentStartingPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
        wFilamentSpineTerminalPointsNEWCurrent = np.array(wSpineTerminalPtPositionNEW)[np.where((wSpineTerminalPtPositionNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
        wFilamentSpineAttachmentPointsNEWCurrent = np.array(wSpineAttachmentPtPositionNEW)[np.where((wSpineAttachmentPtPositionNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
    
    
    ####Remove spines for branch/terminal point identification
        # np.where(np.array(vTypes) == 1)[0].tolist()
        # np.where(np.array(vFilamentsEdges) == x)
        # np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0]
    
        # # vFilamentsEdgesDendritesOnly = np.delete(np.array(vFilamentsEdges),np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0],axis=0)
        # vFilamentsEdgesDendritesOnly=[l.tolist() for l in np.delete(np.array(vFilamentsEdges),np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0],axis=0)]
    
    
        #create new FilamentXYZ for dendrite spilting
        zNewFilamentsXYZ = vFilamentsXYZ[:]
        zNewFilamentsRadius = vFilamentsRadius[:]
        zNewFilamentsEdges = np.array(vFilamentsEdges[:])
        zNewFilamentsTypes = vTypes[:]
    
    ###############################################################################
    ###############################################################################
    ###############################################################################
    #Easier way to identify branch point and terminal points per filament object
    
    
    
    
    
        # res = np.where((wFilamentTerminalPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))
    
        #Comapre 2 numpy array and find matching rows
        # a = np.array([[1,0],[2,0],[3,1],[4,2]])
        # b = np.array([[1,0],[2,0],[4,1]])
        # res = (a[:, None] == b).all(-1).any(-1)
        #np.where(res)
    
        wFilamentTerminalPointsNEWCurrentBranchDepth = np.array(vAllFilamentDendriteBranchDepth)[np.where((wFilamentTerminalPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
        wFilamentTerminalPointsNEWCurrentBranchLength = np.array(vAllFilamentDendriteLength)[np.where((wFilamentTerminalPointsNEW[:, None] == np.array(vFilamentsXYZ)).all(-1).any(-1))[0].tolist()]
    
        wFilamentComplexityNumberPrimaryDendrites = np.size(np.where(wFilamentTerminalPointsNEWCurrentBranchDepth==0))
        wFilamentComplexitySumTerminalBranchOrder = np.sum(wFilamentTerminalPointsNEWCurrentBranchDepth)
    
        wFilamentComplexityIndexCurrent = (wFilamentComplexitySumTerminalBranchOrder + np.size(wFilamentTerminalPointsNEWCurrent[:,0]))/vAllFilamentLengthSum[aFilamentIndex]/wFilamentComplexityNumberPrimaryDendrites
        wFilamentComplexityIndexComplete.append((wFilamentComplexitySumTerminalBranchOrder + np.size(wFilamentTerminalPointsNEWCurrent[:,0]))/vAllFilamentLengthSum[aFilamentIndex]/wFilamentComplexityNumberPrimaryDendrites)
    
    
    # Dendritic complexity index (DCI) was determined from the following equation,
    # DCI = (Σ branch tip orders + #branch tips)×(total dendritic length/total number of primary dendrites).
    
    
    
        wFilamentBranchPointsComplete.extend(wFilamentBranchPointsNEWCurrent.tolist())
        wFilamentTerminalPointsComplete.extend(wFilamentTerminalPointsNEWCurrent.tolist())
    
    
    ###############################################################################
    #Branch Point Classification
        # #identify position index that match branch point
        # np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[i][0])[0].tolist()[0]
        # #identify all filament edges that use that index
        # np.where(np.array(vFilamentsEdges) == np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[0][0])[0].tolist()[0])[0].tolist()
    
    #Terminal Point segmentID Classification
        # #identify position index that match XYZ branch point position
        # np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist()
        # #identify all index of filament edge that use that Point index
        # np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())
    
        # wTerminalSegmentID = np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())[0].tolist()[0]
        # vFilamentsEdgesSegmentId[wTerminalSegmentID]
    
        # np.where(np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist())[0]
        # np.where(np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist())
    
        #Find Terminal segmentIds
        wTerminalSegmentIDs=[]
        for i in range(len(wFilamentTerminalPointsNEWCurrent)):
            wTerminalSegmentIDcurrent = np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())[0].tolist()[0]
            wTerminalSegmentIDs.append(vFilamentsEdgesSegmentId[wTerminalSegmentIDcurrent])
    
    
    
    
    ###############
        wNodeSegments = []
        vNodeTypePerFilament = []
        for i in range(len(wFilamentBranchPointsNEWCurrent)):
    
        #Identify segment IDs that are attached to branch point
            wNodeSegments.append(np.array(vFilamentsEdgesSegmentId)[np.where(np.array(vFilamentsEdges) == np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[i][0])[0].tolist()[0])[0].tolist()].tolist())
            #Identify if segments attached to node are a terminal segment
            #count number per each node
            # len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i]))
            vNodeTypePerFilament.append(len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i])))
            vNodeTypesComplete.append(len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i])))
        #list filamientID for each node
        vNodeFilamentIdsComplete.extend([vFilamentIds[vFilamentCountActual-1]]*len(wFilamentBranchPointsNEWCurrent))
    
            #categories.  1) Arborization, 2)Continuation, 3) Terminal
            #1)Arborization (A) nodes have two bifurcating children.
            #2)Continuation (C) nodes have one bifurcating and one terminating child.
            #3)Termination (T) nodes have two terminating children.
            #4)Other (T+) nodes more than 2 terminating children.
    
    ###############################################################################
    ###############################################################################
        vAllSegmentsPerFilamentRadiusWorkingInserts = []
        vAllSegmentsPerFilamentPositionsWorkingInserts = []
        vAllSegmentsAnglesPerFilament = []
        vAllSegmentsTypesPerFilamentWorkingInserts=[]
        vAllSegmentIdsPerFilamentInserts = []
        vNewStatAnglesPerCurrentFilamentSpot = []
        vNewStatAnglesPerCurrentFilamentSpotMean = []
        vNewStatTortuosityPerSegmentSum = []
        zReorderedvSegmentIds =[]
        zReorderedvSegmentType = []
        wDistanceValuesMax = []
        wDistanceValuesMin = []
    ###############################################################################
        #Loop through dendrite segments, terminal segements and spine segments
        vSegmentBranchDepthCurrent = []
        for vBranchIndex in range (vNumberOfDendriteBranches):
            SegmentCountALL=SegmentCountALL+1
            zReOrderedFilamentPointIndexWorking = []
            zReOrderedFilamentPositionsWorking = []
            zReOrderedFilamentRadiusWorking = []
    ###############################################################################
            # if not vSegmentIds[vBranchIndex] in vAllFilamentDendriteLengthIds:
            #     continue
    
            if np.isin(vSegmentIds[vBranchIndex],np.array(vAllFilamentDendriteLengthIds)) == True or np.isin(vSegmentIds[vBranchIndex],np.array(vAllFilamentSpineLengthIds)) == True:
                zSegment=1
            else:
                continue
    
    ###############################################################################
    #Set the ID for dendrite segment
            vSegmentIdWorking = vSegmentIds[vBranchIndex]
            #Isolate all edges for the working segment
            vSegmentWorkingPointIndex = np.where(np.array(vFilamentsEdgesSegmentId) == vSegmentIdWorking)[0].tolist()
    
            if len(vSegmentWorkingPointIndex)>1:
                vSegmentEdgesWorking=list(itemgetter(*vSegmentWorkingPointIndex)(vFilamentsEdges))
            else:
                vSegmentEdgesWorking=[x[1] for x in enumerate(vFilamentsEdges)
                              if x[0] in vSegmentWorkingPointIndex]
    
            #Match segmentID with Branch Depth Value
            # np.where(np.array(vAllFilamentDendriteBranchDepthIds) == vSegmentIdWorking)[0].tolist()[0]
            vSegmentBranchDepthCurrent.append(vAllFilamentDendriteBranchDepth[np.where(np.array(vAllFilamentDendriteBranchDepthIds) == vSegmentIdWorking)[0].tolist()[0]])
    
            #Find unique edge indices using "set" and convert back to list
            vEdgesUniqueWorking=list(set(x for l in vSegmentEdgesWorking for x in l))
    
       #Find current Working Dendrite segment parts
            vSegmentPositionsWorking=list(itemgetter(*vEdgesUniqueWorking)(vFilamentsXYZ))
            vSegmentRadiusWorking=list(itemgetter(*vEdgesUniqueWorking)(vFilamentsRadius))
            vSegmentTypesWorking=list(itemgetter(*vEdgesUniqueWorking)(vTypes))
    
            #Unit length number of points that make it up
            vSegmentBranchLength.append(len(vEdgesUniqueWorking))
    
            #Collate all SegmentId by Type (dendrtie or spine)
            if max(vSegmentTypesWorking)==0:
                wSegmentIdsDendrite.append(vSegmentIdWorking)
                wSegmentIdsALL.append(vSegmentIdWorking)
            else:
                wSegmentIdsSpine.append(vSegmentIdWorking)
                wSegmentIdsALL.append(vSegmentIdWorking)
                continue
    ##################################################################
    #Test is the segmentlength is too short to reoreeder or fil spots. Currently set to 5
    #         if len(vSegmentPositionsWorking)<3:
    #         #Collate with all data but bypass reorder and Fill steps.
    #             vAllSegmentsPerFilamentRadiusWorkingInserts.extend([vSegmentRadiusWorking])
    #             vAllSegmentsPerFilamentPositionsWorkingInserts.extend([vSegmentPositionsWorking])
    # ##############################################################################
    #         #Measure distance of all FilamentPoint position to Filament Startingn point
    #         #To find out which Denrite segment intersects with each sphere, to
    #         #hopefully reduce the time of process irrelevant segments
    #             wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
    #             wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
    
    #             vNewStatTortuosityPerSegment.append(0)
    
    #             continue
    ###############################################################################
    ###############################################################################
    #find gaps in the dendrite length and fill with extra spots
    #For bouton detect and Spots display
            if max(vSegmentTypesWorking)==0:# and vOptionFilamentToSpotsFill==1 or vOptionFilamentBoutonDetection==1 or vOptionFilamentCloseToSpots==1 or vOptionDendriteToDendriteContact==1 or vOptionFilamentToFilamentContact==1:
    #ReOrder segment
            #Reordering
            #flattten list
                zNum=reduce(operator.concat, vSegmentEdgesWorking)
                #find duplicates
                zDup=[zNum[i] for i in range(len(zNum)) if not i == zNum.index(zNum[i])]
                #find individuals - start and end index
                zIndiv=list(set(zNum).difference(zDup))
    
                zStartIndex=zIndiv[0]
                zEndIndex=zIndiv[1]
                zReOrderedFilamentPointIndexWorking.append(zStartIndex)
                zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zStartIndex])
                zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zStartIndex])
    
            #start of loop for each dendrite segment
                for k in range (len(vSegmentRadiusWorking)-1):
                    if k==0:
                        #find nested list index that contains StartIndex (5,1)--next point is (5,0)
                        #convert tuple to list
                        zEdgesNext=list(reduce(operator.concat, [(index_,sub_list.index(zStartIndex))\
                             for index_, sub_list in enumerate(vSegmentEdgesWorking)\
                             if zStartIndex in sub_list]))
    
                        #find next segment index delete previous one
                        if zEdgesNext[1]==1:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][0]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        else:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][1]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        #collate segment indices
                        zReOrderedFilamentPointIndexWorking.append(zNextSegmentIndex)
                        zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zNextSegmentIndex])
                        zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zNextSegmentIndex])
    
                    else:
                       #find nested list index that contains NextIndex
                       #convert tuple to list
                        zEdgesNext=list(reduce(operator.concat, [(index_,sub_list.index(zNextSegmentIndex))\
                             for index_, sub_list in enumerate(vSegmentEdgesWorking)\
                             if zNextSegmentIndex in sub_list]))
    
                        if zEdgesNext[1]==1:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][0]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        else:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][1]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
    
                        zReOrderedFilamentPointIndexWorking.append(zNextSegmentIndex)
                        zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zNextSegmentIndex])
                        zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zNextSegmentIndex])
                    zReorderedvSegmentIds.extend([vSegmentIdWorking]*len(vSegmentRadiusWorking))
                    zReorderedvSegmentType.extend([max(vSegmentTypesWorking)]*len(vSegmentRadiusWorking))
    
        ##############################################################################
        ##############################################################################
        #fill spots in filament point gaps
                vSegmentRadiusWorkingInserts=zReOrderedFilamentRadiusWorking[:]
                vSegmentPositionsWorkingInserts=zReOrderedFilamentPositionsWorking[:]
                if max(vSegmentTypesWorking)==0:
                    for loop in range (3):#loop through 3 times
                        i=0
                        while i<=(len(vSegmentPositionsWorkingInserts)-2):
                            vFillFilamentPairDist=pdist([vSegmentPositionsWorkingInserts[i],vSegmentPositionsWorkingInserts[i+1]])
                            vFillFilamentRadialSum=vSegmentRadiusWorkingInserts[i]+vSegmentRadiusWorkingInserts[i+1]
                            if vFillFilamentPairDist>vFillFilamentRadialSum:
            #insert Radius at next spot
                                vSegmentRadiusWorkingInserts[i+1:i+1]=[vFillFilamentRadialSum/2]
                                vSegmentPositionsWorkingInserts[i+1:i+1]=[np.divide(np.add(vSegmentPositionsWorkingInserts[i+1],
                                                                                            vSegmentPositionsWorkingInserts[i]),2).tolist()]
                            i=i+1
                vAllSegmentsPerFilamentRadiusWorkingInserts.extend([vSegmentRadiusWorkingInserts])
                vAllSegmentsPerFilamentPositionsWorkingInserts.extend([vSegmentPositionsWorkingInserts])
                # vAllSegmentsTypesPerFilamentWorkingInserts.extend([max(vSegmentTypesWorking)]*len(vSegmentRadiusWorkingInserts))
                # vAllSegmentIdsPerFilamentInserts.extend([vSegmentIdWorking]*len(vSegmentRadiusWorkingInserts))
    ##############################################################################
    ############Calculating dendrite angles, by spiltting each segment into small bits
                ##Calcualte the angle between each adjacent points along the segment
                # vSegmentAngles =[]
                # vAnglesPerCurrentSegment =[]
                # vAnglesPerCurrentSegmentMean = []
                # if len(vSegmentPositionsWorkingInserts) > 2:
                #     for i in range(len(vSegmentPositionsWorkingInserts)-2):
                #         # Determine the plane position of the 3 reference points
                #         p1 = np.array(vSegmentPositionsWorkingInserts[i]) # Position of first point on plane
                #         p2 = np.array(vSegmentPositionsWorkingInserts[i+1]) # Position of second point on plane
                #         p3 = np.array(vSegmentPositionsWorkingInserts[i+2]) # Position of third point on plane
                #         # These two vectors are in the plane
                #         v1 = p3 - p1
                #         v2 = p2 - p1
                #         #dot product
                #         p = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
                #         #compute norms
                #         n1 = math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2])
                #         n2 = math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2])
                #         #Compute angle
                #         try:
                #             ang = math.acos(p / (n1 * n2))
                #         except:
                #             ang = math.acos(1)
    
                #         # Convert to degrees if you want
                #         vSegmentAngles.append(math.degrees(ang))
                # else:
                #     vSegmentAngles.append(0)
                # vAnglesPerCurrentSegment.append(vSegmentAngles)
    
                # #Calcualte the average of every second
                # #Every spot in current segment with mean angle
                # if len(vAnglesPerCurrentSegment[0]) == 2:
                #     vAnglesPerCurrentSegmentMean.append(mean(vAnglesPerCurrentSegment[0]))
                # elif len(vAnglesPerCurrentSegment[0]) == 1:
                #         vAnglesPerCurrentSegmentMean.append(vAnglesPerCurrentSegment[0])
                # else:
                #     for i in range (len(vAnglesPerCurrentSegment[0])):
                #         vAnglesPerCurrentSegmentMean.append(mean(vAnglesPerCurrentSegment[0][i:i+2]))
                #     vAnglesPerCurrentSegmentMean[-1] = mean(vAnglesPerCurrentSegmentMean[-2:])
                #     vAnglesPerCurrentSegmentMean[-2] = mean(vAnglesPerCurrentSegmentMean[-3:])
    
                # # #compile all spot angle values for each point into single variable
                # # vCompleteSegmentsAnglesPerFilamentSpot.extend(vAnglesPerCurrentSegment)
                # # vCompleteSegmentsAnglesPerFilamentSpotMean.extend(vAnglesPerCurrentSegmentMean)
    
                # #compile all angles for each point current filament
                # vNewStatAnglesPerCurrentFilamentSpot.extend(vAnglesPerCurrentSegment)
                # vNewStatAnglesPerCurrentFilamentSpotMean.extend(vAnglesPerCurrentSegmentMean)
    
                # #Calculate Tortuosity
                # if vSegmentAngles[0] == 0:
                #     vNewStatTortuosityPerSegment.append(float(0))
                # elif len(vSegmentAngles)==1 and vSegmentAngles[0]>0:
                #     vNewStatTortuosityPerSegment.append(float(sum(abs(np.array(vAnglesPerCurrentSegmentMean[0])))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi))
                # else:
                #     vNewStatTortuosityPerSegment.append(float(sum(abs(np.array(vAnglesPerCurrentSegmentMean)))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi))
    
                # vNewStatCompleteTortuosityPerSegmentSum.append(sum(abs(np.array(vAnglesPerCurrentSegmentMean))))
                # vNewStatCompleteTortuosityPerSegment.append(sum(abs(np.array(vAnglesPerCurrentSegmentMean)))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi)
    
    ##############################################################################
            #Measure distance of all FilamentPoint position to Filament Startingn point
            #To find out which Denrite segment intersects with each sphere, to
            #hopefully reduce the time of process irrelevant segments
            # if len(zIndiv)<2:
            #     wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
            #     wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
            # else:
            wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorkingInserts)))
            wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorkingInserts)))
    ##############################################################################
    ##############################################################################
    # Insert dual progress bar one dendrite branches
    # one for filaments
        #Progress bar for dendrite segments
            progress_bar1['value'] = int((vBranchIndex+1)/vNumberOfDendriteBranches*100) #  % out of 100
            qProgressBar.update()
            elapsed = time.time() - start
            #print('ReOrdered')
    ##############################################################################
    ##############################################################################
    
    #Create a normalize color basd on the number of potential Sholl spheres
            wApproxNumSpheres=(max(wDistanceValuesMax)/vShollRadius).astype(int)
            wColorList=np.linspace(start=.1,stop=.9,num=wApproxNumSpheres)
    
            zShollLabelsFinal=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+1), vShollRadius))
    
    ##############################################################################
        vShollSpotCount=0
        vShollNodeCount=0
    ################################################
        wCompleteShollSpotDistAlongFilamentStatWorking=[]
        wCompleteTerminalPointsDistAlongFilamentStatWorking=[]
        wCompleteBranchPointsDistAlongFilamentStatWorking=[]
    
        vDendriteALLXSphere=[]
        qSpotinQuestionALL=[]
    ################################################
    ################################################
        aIntensityLowerThresholdManual=5
        aShollIndex=0
        vBranchIndex=0
        zShollLabelsAll=[]
        vShollFinalIndex=0
        vNumberofShollIntersectionsCurrent=[0]*5
        start2 = time.time()
    
    #Progress through each Sholl Sphere
        for aShollIndex in range (round(max(wDistanceValuesMax))):
            vSpotPositionCurrentShollSphere=[]#Clears current Sholl spots
            count=0
            #Set lower and upper threshold for the Sholl Mask
            aIntensityLowerThresholdManual=aIntensityLowerThresholdManual+1
            aIntensityUpperThresholdManual=aIntensityLowerThresholdManual+(aXvoxelSpacing*2)
            qSpotinQuestion=[]
            qNodeinQuestion=[]
            qShollSpotNodeClassify=[]
    
    #Create list of Sholl labels
            zShollLabelsAll.append(str(aIntensityLowerThresholdManual))
    
        # Process a each branch and find point distance to starting point
        # filter by current sholl sphere distance
        # Test if Dendrite fails on the Sholl sphere
        #find the indices of segments that cross the current Sholl Sphere
            vSegmentsCurrentShollSphereIndexMax=[index for index,value in enumerate(wDistanceValuesMax)
                                              if value >= aIntensityLowerThresholdManual]
            vSegmentsCurrentShollSphereIndexMin=[index for index,value in enumerate(wDistanceValuesMin)
                                              if value <= aIntensityLowerThresholdManual]
            wSegmentIndexIntersectSholl=list(set(vSegmentsCurrentShollSphereIndexMax).intersection(vSegmentsCurrentShollSphereIndexMin))
    
    
    
    
    
    
    
            if wSegmentIndexIntersectSholl==[]:
                break
    ##############################################################################
            # start = time.time()
    
            for vBranchIndex in range (len(wSegmentIndexIntersectSholl)):
                vDendritePositionsNEW=vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]]
                #Measure distance from each point to starting for current segment
                vDistanceListValues=cdist([vBeginningVertexPositionXYZ],
                                          vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]])
                #Set base for each filament point to false
                vDendriteXSphere = np.array([0]*(np.size(vDistanceListValues)))
                #Test filament points to find those near current sholl sphere
                wShollIntersectionIndex=np.where(np.logical_and(vDistanceListValues>float(aIntensityLowerThresholdManual), vDistanceListValues<aIntensityUpperThresholdManual))
                wShollIntersectionIndex = wShollIntersectionIndex[1].tolist()
    
            #if no filament point is detected, within these defined limits
                #find the closest point and use that as the lone Sholl intersection
                if len(wShollIntersectionIndex)==0:#if list array is empty
                    wShollIntersectionIndex = np.where(abs(vDistanceListValues-aIntensityLowerThresholdManual) == np.amin(abs(vDistanceListValues-aIntensityLowerThresholdManual)))[1].tolist()
                #convert to real numbers
                vDendriteXSphere[np.array(wShollIntersectionIndex)]=int(1)
                #convert to positionsXYZ
                # vDendriteXSpherePositionXYZ=itemgetter(*wShollIntersectionIndex[1].tolist())(vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]])
                if len(vDendriteXSphere)>0:
                    #Need to add one zero to the end of series so that a peak can be identified at the tail end
                    vDendriteXSphere=np.pad(vDendriteXSphere, (0,2), 'constant')
                    PeakIndex, _ = find_peaks(vDendriteXSphere, height=0.25)
                    # remove the trailing zero
                    PeakIndexWorking=PeakIndex.tolist()
                    #Test for single gaps in the dendrite peak and fill them. Likely not
                    #enough to warrrent a true Sholl intersection cross
                    if len(PeakIndexWorking)>1:
                        for i in range(len(PeakIndexWorking)-1):
                            if PeakIndexWorking[i]+1==PeakIndexWorking[i+1]-1:
                                vDendriteXSphere[PeakIndexWorking[i]+1]=1
    
                    #reset binary segment to original removing doube pad
                    vDendriteXSphere = vDendriteXSphere[:-1]
                    vDendriteXSphere = vDendriteXSphere[:-1]
    #qSpotinQuestion Scenarios
    #1---single point at begining of segment
    #2---multiple points at beginning of segment
    #3---all points including fist and last
    #4---single point at the end
    #5---multiple points at the end
    #0---no issues
    
    #########################
        #Scenario#1----Test if first point is a sholl intersection -add to peak index list
                    if vDendriteXSphere[0]==1:
                        PeakIndexWorking=np.insert(PeakIndexWorking, 0, 0).astype(int)
    ##################################################
                    #compile each segments peaks
                    vDendriteALLXSphere.append(vDendriteXSphere)
    
                #Analysis of each Peak index and surrounding peaks
                    for i in range(len(PeakIndexWorking)):
                        count=0
                        b=vDendriteXSphere[PeakIndexWorking[i]:]#generated series starting from next peakpoint
                        b=np.append(b,0)
                        while b[count]==1:
                            count=count+1
                    #Is peak at front end of semgent (2 in length)
                        if PeakIndexWorking[i]==0:
                            # vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            qSpotinQuestion=True
                            if count==1:
                                qShollSpotNodeClassify.append(1)
                            else:
                                qShollSpotNodeClassify.append(2)
                            qNodeinQuestion.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            vShollNodeCount=vShollNodeCount+1
                            vShollSpotCount=vShollSpotCount+1
    
                    #Is peak at tail end of semgent (2 in length)- branch or terminal
                        elif PeakIndexWorking[i]!=0 and vDendriteXSphere[-1]==1:
                            vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[-1])# grab last point in segment
                        #Test if this Sholl Intersection is a Terminal point
                            qIsSpotaTerminalPoint =  any(item in wFilamentTerminalPointsNEWCurrent for item in vSpotPositionCurrentShollSphere[-1])
                            if qIsSpotaTerminalPoint == True:
                                vShollSpotCount=vShollSpotCount+1
                            else:
                                del vSpotPositionCurrentShollSphere[-1]#Remove added Sholl spot position
                                qSpotinQuestion=True
                                if count==1:
                                    qShollSpotNodeClassify.append(3)
                                else:
                                    qShollSpotNodeClassify.append(4)
                                qNodeinQuestion.append(vDendritePositionsNEW[-1])
                                vShollNodeCount=vShollNodeCount+1
                                vShollSpotCount=vShollSpotCount+1
                        else:
                            vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            vShollSpotCount=vShollSpotCount+1
            elapsed = time.time() - start
            #print('ProcessBranches')
    ###############################################################################
    ###############################################################################
    
    ###############################################
    ###############################################
    #Correct the edge related intersections - after last branch index
    #Process and remove duplicate spots and reduce spots near node.
            if qSpotinQuestion==True:#Test if there are any questionable intersections
                #Find Unique Spots, counts and indices in question
                qUniqueNodes, qUniqueIndex,qUniqueCounts = np.unique(np.array(qNodeinQuestion), return_counts=True, return_index=True, axis=0)
                for qIndex in range (len(qUniqueIndex)):
                    #Find index of unique nodes in question
                    qNodeinQuestionIndexWorking=np.where((qNodeinQuestion == qUniqueNodes[qIndex]).all(axis=1))[0].tolist()
                    if qUniqueCounts[qIndex]==1:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-1
                    if qUniqueCounts[qIndex]==2:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-1
                    if qUniqueCounts[qIndex]==3:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-2
                    if qUniqueCounts[qIndex]==4:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-3
    
    ###############################################################################
            #Compile all Sholl Intersections per Sholl sphere (uneditted)
            vSpotPositionAllShollSpheresALL.extend([vSpotPositionCurrentShollSphere])
            vSpotPositionAllShollSpheresPerFilamentALL.extend([vSpotPositionCurrentShollSphere])
            #Number of sholl intersections per filament
            vNumberofShollIntersectionsCurrent.append(len(vSpotPositionCurrentShollSphere))
            vNumberofShollIntersectionsALL.append(len(vSpotPositionCurrentShollSphere))
            vNewStatSpotShollDistanceALL.extend([aIntensityLowerThresholdManual]*len(vSpotPositionAllShollSpheresPerFilamentALL[aShollIndex]))
    
            if aIntensityLowerThresholdManual in zShollLabelsFinal:
                #Compile all Sholl Intersections per Sholl sphere (uneditted)
                vSpotPositionAllShollSpheres.extend([vSpotPositionCurrentShollSphere])
                vSpotPositionAllShollSpheresPerFilament.extend([vSpotPositionCurrentShollSphere])
                #Number of sholl intersections per filament
                vNumberofShollIntersections.append(len(vSpotPositionCurrentShollSphere))
                vNewStatSpotShollDistance.extend([aIntensityLowerThresholdManual]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]))
    
    ###############################################################################
        #Create Sholl Spots for the current Sholl Sphere for current Filament
                vShollCurrentSpotRadius=[1]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex])
                vShollCurrentSpotTime=[vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex])
    
                if len(vShollCurrentSpotRadius) > 0 and qSplitShollspheres == 1:
                    #Create the a new Spots generated from teh center of Mass
                    vNewSpots = vImarisApplication.GetFactory().CreateSpots()
                    vNewSpots.Set(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex],
                                  [vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]),
                                  [1]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]))
                    vNewSpots.SetName('FilamentID:'+str(vFilamentIds[vFilamentCountActual-1]) +
                        ' -- ' + str(aIntensityLowerThresholdManual) +
                                      ' um Sholl Sphere')
                    zRandomColor=((wColorList[vShollFinalIndex]) * 256 * 256 * 256 )
                    vNewSpots.SetColorRGBA(zRandomColor)#Set Random color
                    #Add new spots to Surpass Scene
                    vShollResult.AddChild(vNewSpots, -1)
                    vImarisApplication.GetSurpassScene().AddChild(vShollResult, -1)
    
            #Number of sholl intersections per sholl sphere
                vNumberofIntersectionsPerShollSphere.append(len(vSpotPositionCurrentShollSphere))
                vNewStatSpotNumberShollIntersections.extend([vNumberofIntersectionsPerShollSphere[vShollFinalIndex]]*vNumberofIntersectionsPerShollSphere[vShollFinalIndex])
    
        #Reset stat for next Sholl Sphere
                vSpotPositionCurrentShollSphere=[]
                vShollSpotTime=[]
                vShollSpotRadius=[]
                vShollSpotCount=0
                vDendriteALLXSphere=[]
                vShollFinalIndex=vShollFinalIndex+1
    
        elapsed = time.time() - start2
        print(elapsed)
        #after the last sholl sphere
        vNewStatNumberShollIntersectionPerFilament.append(sum(vNumberofShollIntersections))
        vNumberOfShollIntersectionPerSpherePerFilament.extend(vNumberofIntersectionsPerShollSphere)
        vNumberofShollIntersections=[]
        vNumberofIntersectionsPerShollSphere=[]
    
        vNewFilamentStatCriticalRadiusHighRes=(np.argmax(np.array(vNumberofShollIntersectionsCurrent))+1).tolist()
        vNewFilamentStatMaxIntersectionsHighRes=(np.max(np.array(vNumberofShollIntersectionsCurrent))).tolist()
    
    
    
    
    
        vNumberofShollIntersectionsCurrent = []
    
    ###############################################################################
        #Calculate slope???Linear regression
        #From Critical radius to outer ring
        # x = vNumberofShollIntersectionsALL[vNewFilamentStatMaxIntersectionsHighRes:len(vNumberofShollIntersectionsALL)+1]
        # y = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))
    
        # zLinearRegressionSlope, zLinearRegressionIntercept, zLinearRegression_r, zLinearRegression_p, zLinearRegression_std_err = stats.linregress(x, y)
    
        # def myfunc(x):
        #   return slope * x + intercept
    
        # mymodel = list(map(myfunc, x))
    
        # plt.scatter(x, y)
        # plt.plot(x, mymodel)
        # plt.show()
    
    ###############################################################################
        #Logaithmic Regression
        # import math
        # from math import log
    
        # from scipy.stats import linregress
    
    
        # # distal list of sholl intersection pe 1um after max interval
        # zDistIndX = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))
        # zDistNumberShollInt = [ vNumberofShollIntersectionsALL[i-1] for i in x]
    
        # # proximal list of sholl intersection pe 1um before max interval
        # zProxIndX = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))
        # zProxNumberShoollInt = [ vNumberofShollIntersectionsALL[i-1] for i in x]
        # #Linear slope of the line
        # zProxSlope = linregress(zProxIndX, zProxNumberShoollInt)
        # zDistSlope = linregress(zDistIndX, zDistNumberShollInt)
    
    
        # # proximal list of sholl intersection pe 1um before max interval
        # zProxIndX = np.array(list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL))))
        # zProxNumberShollInt = np.log(np.array([ vNumberofShollIntersectionsALL[i-1] for i in x]))
        # # distal list of sholl intersection pe 1um after max interval
        # zDistIndX = np.array(list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL))))
        # zDistNumberShollInt = np.log(np.array([ vNumberofShollIntersectionsALL[i-1] for i in x]))
        # #linear repression log log plot
        # zProxSlope, zProxIntercept = np.polyfit(np.log(zProxIndX), zProxNumberShollInt, 1)
        # zDistSlope, zDistIntercept = np.polyfit(np.log(zDistIndX), zDistNumberShollInt, 1)
    
    
    
    
    
    
    
    
        # x=[log(i) for i in x]
        # xNEW=[x[i]/(y[i]*y[i]*math.pi) for i in range(len(x))]
    
        #fit the model
        # plt.scatter(x, y)
        # plt.show()
        # fit = np.polyfit(np.array(xNEW), np.array(y), 1)
    
        # #view the output of the model
        # print(fit)
    
    
    
    ###############################################################################
    ###############################################################################
    #Spilt Dendrite segments at the point of Sholl intersection
        if qOptionShollDendrites == 1:
        #Create new label/statistic to id
            #Spilt out Final defined sholl spheres to new value
            # vFinalShollSpheres=[vSpotPositionAllShollSpheresPerFilament[i] for i in [i-1 for i in zShollLabelsFinal]]
            #flatten all Sholl intersection to single list
            vSpotPositionAllShollSpheresFlat = [x for xs in vSpotPositionAllShollSpheresPerFilament for x in xs]
    
        #Find spot on each filament and delete the spot to split dendrite at the sholl intersection
            for qIndexShollPosition in range(len(vSpotPositionAllShollSpheresFlat)):
                zShollxyzCurrent=vSpotPositionAllShollSpheresFlat[qIndexShollPosition]
                zShollxyz=np.array(vFilamentsXYZ).T
                zClosestDistanced3D = ( (zShollxyz[0] - zShollxyzCurrent[0]) ** 2 + (zShollxyz[1] - zShollxyzCurrent[1]) ** 2 + (zShollxyz[2] - zShollxyzCurrent[2]) ** 2) ** 0.5#for3D
                zClosest_index = np.argmin(zClosestDistanced3D)
                zClosest = vFilamentsXYZ[zClosest_index]
                #Find/delete Edges Index from original FilamentEdges
                # zNewFilamentsEdges=(np.delete(zNewFilamentsEdges,zClosest_index,0)).tolist()
                try:
                    zNewFilamentsEdges=(np.delete(zNewFilamentsEdges, np.where(zNewFilamentsEdges==zClosest_index)[0][0],0)).tolist()
                except:
                    x=1
    
        #Create a NEW Filament object with dendrite segments split
            vNewFilaments=vImarisApplication.GetFactory().CreateFilaments()
            vNewFilaments.AddFilament(zNewFilamentsXYZ, zNewFilamentsRadius, zNewFilamentsTypes, zNewFilamentsEdges, vFilamentsIndexT)
            vNewFilaments.SetName('Sholl Dendrites (ID: ' + str(vFilamentIds[vFilamentCountActual-1])+')')
    
            vNewFilaments.SetName('FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1])+' -- Sholl Dendrites')
    
            vShollDendrites.AddChild(vNewFilaments, -1)
            vImarisApplication.GetSurpassScene().AddChild(vShollDendrites, -1)
    
        #Get Dendrite position stats
            zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Dendrite Position X').mValues
            zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Dendrite Position Y').mValues
            zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Dendrite Position Z').mValues
            zStatisticDendriteLength= vNewFilaments.GetStatisticsByName('Dendrite Length').mValues
            zStatisticDendriteIds = vNewFilaments.GetStatisticsByName('Dendrite Position X').mIds
            if zStatisticDendriteLength == []:
                aVersionValue = 10
                zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Segment Position X').mValues
                zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Segment Position Y').mValues
                zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Segment Position Z').mValues
                zStatisticDendriteLength= vNewFilaments.GetStatisticsByName('Segment Length').mValues
                zStatisticDendriteIds = vNewFilaments.GetStatisticsByName('Segment Position X').mIds
    
        #Measure distance from each Dendrite position to starting point
             #Collate XYZ positions in to a single list
            zNewDendritesPosXYZ=[list(t) for t in zip(zStatisticDendritePosX, zStatisticDendritePosY, zStatisticDendritePosZ)]
            zDistanceDendriteListValues=cdist([vBeginningVertexPositionXYZ], zNewDendritesPosXYZ)
            zDistanceDendriteListValues=zDistanceDendriteListValues.transpose()
    
        #CreateLabels for each Sholl sphere
            # scount=0
            # zShollLabelsAll = [20]
            # i=0
            vNewFilamentsStatId=[]
            vNewFilamentsStatLength=[]
            vNewFilamentsStatShollSphere=[]
    
            zShollLabelsInt=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+2), vShollRadius))
    
            # zShollLabelsInt = [int(i) for i in zShollLabelsFinal]
            zShollLabelsInt.insert(0,0)#insert a zero at start of list
            vLabelIndices=[]
            for i in range (len(zShollLabelsInt)-1):
                zDistanceDendriteListValues=np.where((zDistanceDendriteListValues > zShollLabelsInt[i]) &
                                 (zDistanceDendriteListValues <= zShollLabelsInt[i+1]),zShollLabelsInt[i+1], zDistanceDendriteListValues)
        ###Creating new statistics for segmented dendrite length
                vNewFilamentsStatLength.append(sum([zStatisticDendriteLength[i]
                                                    for i in np.where(zDistanceDendriteListValues==zShollLabelsInt[i+1])[0].tolist()]))
    
        ###############################################################################
            #Add Sholl Statistics
            vNewFilamentsStatvIds=list(range(len(zStatisticDendriteIds)))
            vNewFilamentsStatUnits=['']*(len(zStatisticDendriteIds))
            if aVersionValue < 10:
                vNewFilamentsStatFactors=(['Dendrite']*len(zStatisticDendriteIds), [str(vFilamentsIndexT+1)]*len(zStatisticDendriteIds))
            else:
                vNewFilamentsStatFactors=(['Segment']*len(zStatisticDendriteIds), [str(vFilamentsIndexT+1)]*len(zStatisticDendriteIds))
            vNewFilamentsStatFactorName=['Category','Time']
        #######################
            vNewFilamentsIdStat=[vFilamentIds[vFilamentCountActual-1]-100000000]*len(zStatisticDendriteIds)
            vNewFilamentsStatNames=[' xFilament ID']*(len(zStatisticDendriteIds))
            vNewFilaments.AddStatistics(vNewFilamentsStatNames, vNewFilamentsIdStat,
                                  vNewFilamentsStatUnits, vNewFilamentsStatFactors,
                                  vNewFilamentsStatFactorName, zStatisticDendriteIds)
        ########################
            vNewFilamentsStatShollSphere=zDistanceDendriteListValues.tolist()
            vNewFilamentsStatShollSphere = [x for xs in vNewFilamentsStatShollSphere for x in xs]
            vNewFilamentsStatNames=[' Sholl Sphere']*(len(zStatisticDendriteIds))
            vNewFilaments.AddStatistics(vNewFilamentsStatNames, vNewFilamentsStatShollSphere,
                                  vNewFilamentsStatUnits, vNewFilamentsStatFactors,
                                  vNewFilamentsStatFactorName, zStatisticDendriteIds)
    
    ###############################################################################
    ###############################################################################
    
    ###############################################################################
    #Create Sholl Spots object for each filament with new stats
        vNewShollSpotsPerFilament = vImarisApplication.GetFactory().CreateSpots()
    
        # vFinalShollSpheres=[vSpotPositionAllShollSpheresPerFilament[i] for i in [i-1 for i in zShollLabelsFinal]]
        #may need to flatten spot list of lists
        vSpotPositionAllShollSpheresPerFilament = [num for elem in vSpotPositionAllShollSpheresPerFilament for num in elem]
    
    
        vNewShollSpotsPerFilament.Set(vSpotPositionAllShollSpheresPerFilament,
                              [vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament),
                              [1]*len(vSpotPositionAllShollSpheresPerFilament))
        vNewShollSpotsPerFilament.SetName(' Sholl - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewShollSpotsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
        vShollResult2.AddChild(vNewShollSpotsPerFilament, -1)
        vImarisApplication.GetSurpassScene().AddChild(vShollResult2, -1)
    
    #Create Spots for each Terminal Point
        if qOptionTerminalPoints == 1 and qOptionMergePoints == 0:
            vNewSpotsTerminalPointsPerFilament = vImarisApplication.GetFactory().CreateSpots()
            vNewSpotsTerminalPointsPerFilament.Set(wFilamentTerminalPointsNEWCurrent.tolist(),
                                  [vFilamentsIndexT]*len(wFilamentTerminalPointsNEWCurrent.tolist()),
                                  [1]*len(wFilamentTerminalPointsNEWCurrent.tolist()))
            vNewSpotsTerminalPointsPerFilament.SetName(' TerminalPoints - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
            zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
            vNewSpotsTerminalPointsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
            vSpotFilamentPoints.AddChild(vNewSpotsTerminalPointsPerFilament, -1)
            vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)
    
    #Create Spots for each Branch Point
        if qOptionBranchPoints == 1 and qOptionMergePoints == 0:
            vNewSpotsBranchPointsPerFilament = vImarisApplication.GetFactory().CreateSpots()
            vNewSpotsBranchPointsPerFilament.Set(wFilamentBranchPointsNEWCurrent.tolist(),
                                  [vFilamentsIndexT]*len(wFilamentBranchPointsNEWCurrent.tolist()),
                                  [1]*len(wFilamentBranchPointsNEWCurrent.tolist()))
            vNewSpotsBranchPointsPerFilament.SetName(' BranchPoints - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
            zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
            vNewSpotsBranchPointsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
            vSpotFilamentPoints.AddChild(vNewSpotsBranchPointsPerFilament, -1)
            vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)
    
        #############################################################
        #Add new stats
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsvIds=list(range(len(vSpotPositionAllShollSpheresPerFilament)))
        vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsStatFactors=(['Spot']*len(vSpotPositionAllShollSpheresPerFilament), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        ###########################
        vSpotsStatNames=[' Sholl Sphere Distance']*len(vSpotPositionAllShollSpheresPerFilament)
        vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, vNewStatSpotShollDistance,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)
        ###########################
        vSpotsStatUnits=['']*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsStatNames=[' Number of Intersections']*len(vSpotPositionAllShollSpheresPerFilament)
        vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, vNewStatSpotNumberShollIntersections,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)
    
    ###############################################################################
    #Add Overall statistics for sum dendrite length per sholl sphere
            #Insert an overall Statistics
        vOverallStatIds=[int(-1)]
        vOverallStatUnits_um=['um']*vSizeT
        vOverallStatUnits=['']*vSizeT
        vOverallStatFactorsTime=list(range(1,vSizeT+1))
        vOverallStatFactors=[['Overall'],[str(i) for i in vOverallStatFactorsTime]]
        vOverallStatFactorNames=['FactorName','Time']
    ###########
    #Calculate and report the Critical Radius (radius with the highest density)
        vNewFilamentStatCriticalRadius=[vNewStatSpotShollDistance[vNewStatSpotNumberShollIntersections.index(max(vNewStatSpotNumberShollIntersections))]]
        vNewFilamentStatMaxIntersections=[max(vNewStatSpotNumberShollIntersections)]
    
        vOverallStatNames = [' Sholl Critical Radius']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, vNewFilamentStatCriticalRadius,
                                                vOverallStatUnits_um, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Max # Intersections']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, vNewFilamentStatMaxIntersections,
                                                vOverallStatUnits, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Critical Radius HighRes']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentStatCriticalRadiusHighRes],
                                                vOverallStatUnits_um, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Max # Intersections HighRes']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentStatMaxIntersectionsHighRes],
                                                vOverallStatUnits, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
    
    ###############################################################################
    ###############################################################################
    #Calculate sholl intersection distance on dendrite to starting point
    ###############################################################################
    # #Find Spot close to filament and measure distance along path to starting point
    # #Make spot position conect to filament as spine attachment point
    
        if vSpotPositionAllShollSpheresPerFilament!=[]:
            if vBeginningVertex !=-1:
                wNewFilamentsEdges=list(vFilamentsEdges)
                wNewFilamentsRadius=list(vFilamentsRadius)
                wNewFilamentsXYZ=list(vFilamentsXYZ)
                wNewFilamentsTypes=list(vTypes)
    
                wNewFilamentsEdgesTerminal=list(vFilamentsEdges)
                wNewFilamentsRadiusTerminal=list(vFilamentsRadius)
                wNewFilamentsXYZTerminal=list(vFilamentsXYZ)
                wNewFilamentsTypesTerminal=list(vTypes)
    
                wNewFilamentsEdgesBranch=list(vFilamentsEdges)
                wNewFilamentsRadiusBranch=list(vFilamentsRadius)
                wNewFilamentsXYZBranch=list(vFilamentsXYZ)
                wNewFilamentsTypesBranch=list(vTypes)
    
                #Create array of distance measures to original filament points
                wSpotToAllFilamentDistanceArrayOriginal=cdist((np.array(vSpotPositionAllShollSpheresPerFilament)),vFilamentsXYZ)
                wSpotBranchPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentBranchPointsNEWCurrent,vFilamentsXYZ)
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentTerminalPointsNEWCurrent,vFilamentsXYZ)
                wSpotSpineTerminalPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentSpineTerminalPointsNEWCurrent,vFilamentsXYZ)
                wSpotSpineAttachmentPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentSpineAttachmentPointsNEWCurrent,vFilamentsXYZ)
    
                wBranchIdxBlock = np.where(wSpotBranchPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()
                wTerminalIdxBlock = np.where(wSpotTerminalPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()
                wSpineTerminalIdxBlock = np.where(wSpotSpineTerminalPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()
                wSpineAttachmentPointIdxBlock = np.where(wSpotSpineAttachmentPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()
    
                # #Replace zeros with large number
                wSpotToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999
    
                wSpotToAllFilamentDistanceArrayOriginal[:,wSpineTerminalIdxBlock]=9999
                wSpotToAllFilamentDistanceArrayOriginal[:,wSpineAttachmentPointIdxBlock]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,wSpineTerminalIdxBlock]=9999
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,wSpineAttachmentPointIdxBlock]=9999
    
                #Replace Starting point from FilamentXYZ with col of large 9999
                # (np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,[(np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]]]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,[(np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]]]=9999
    
                #For each spot, find index on filament of closest point
                wSpotsFilamentClosestDistancePointIndex=np.argmin(wSpotToAllFilamentDistanceArrayOriginal, axis=1)
                wSpotsBranchPointsFilamentClosestDistancePointIndex=np.argmin(wSpotBranchPointToAllFilamentDistanceArrayOriginal, axis=1)
                wSpotsTerminalPointsFilamentClosestDistancePointIndex=np.argmin(wSpotTerminalPointToAllFilamentDistanceArrayOriginal, axis=1)
    
                #loop for each spot within threshold
                #append new filament and create list of new spots
                for i in range (len(vSpotPositionAllShollSpheresPerFilament)):
                    wNewFilamentsXYZ.append(((np.array(vSpotPositionAllShollSpheresPerFilament))+.00001)[i].tolist())
                    wNewFilamentsRadius.append(1)
                    wNewFilamentsEdges.append([wSpotsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypes.append(1)
    
                #loop for each Terminal Point
                #append new filament and create list of new spots
                for i in range (len(wFilamentTerminalPointsNEWCurrent)):
                    wNewFilamentsXYZTerminal.append((wFilamentTerminalPointsNEWCurrent+0.00001)[i].tolist())
                    wNewFilamentsRadiusTerminal.append(1)
                    wNewFilamentsEdgesTerminal.append([wSpotsTerminalPointsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypesTerminal.append(1)
    
                #loop for each Branch Point
                #append new filament and create list of new spots
                for i in range (len(wFilamentBranchPointsNEWCurrent)):
                    wNewFilamentsXYZBranch.append((wFilamentBranchPointsNEWCurrent+0.00001)[i].tolist())
                    wNewFilamentsRadiusBranch.append(1)
                    wNewFilamentsEdgesBranch.append([wSpotsBranchPointsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypesBranch.append(1)
    
                vNewFilament = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilament.AddFilament(wNewFilamentsXYZ, wNewFilamentsRadius, wNewFilamentsTypes, wNewFilamentsEdges, vFilamentsIndexT)
                vNewFilament.SetBeginningVertexIndex(0, vBeginningVertex)
    
                vNewFilamentBranch = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilamentBranch.AddFilament(wNewFilamentsXYZBranch, wNewFilamentsRadiusBranch, wNewFilamentsTypesBranch, wNewFilamentsEdgesBranch, vFilamentsIndexT)
                vNewFilamentBranch.SetBeginningVertexIndex(0, vBeginningVertex)
    
                vNewFilamentTerminal = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilamentTerminal.AddFilament(wNewFilamentsXYZTerminal, wNewFilamentsRadiusTerminal, wNewFilamentsTypesTerminal, wNewFilamentsEdgesTerminal, vFilamentsIndexT)
                vNewFilamentTerminal.SetBeginningVertexIndex(0, vBeginningVertex)
    
    ###########
        #Grab New Filament Spine Statistics for attachment point distance.
                for aIndex in range(3):#Loop for each
                    # vNewFilamentStatistics=[]
                    if aIndex==0:
                        vNewFilamentSpineAttPtDistSET = vNewFilament.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilament.GetStatisticsByName('Spine Attachment Pt Position X')
                    if aIndex==1:
                        vNewFilamentSpineAttPtDistSET = vNewFilamentTerminal.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilamentTerminal.GetStatisticsByName('Spine Attachment Pt Position X')
                    if aIndex==2:
                        vNewFilamentSpineAttPtDistSET = vNewFilamentBranch.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilamentBranch.GetStatisticsByName('Spine Attachment Pt Position X')
    
                    vNewFilamentSpineAttPtDistValues = vNewFilamentSpineAttPtDistSET.mValues
                    vNewFilamentSpineAttPtDistIds = vNewFilamentSpineAttPtDistSET.mIds
                    vNewFilamentSpineAttPtPosXValues = vNewFilamentSpineAttPtPosXSET.mValues
                    vNewFilamentSpineAttPtPosXIds = vNewFilamentSpineAttPtPosXSET.mIds
    
                    if aIndex==0:
                    #Collate all Sholl spots for each filament
                        for i in range (len(vSpotPositionAllShollSpheresPerFilament)):
                            wCompleteShollSpotDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsFilamentClosestDistancePointIndex[i]][0])])])
    
                    if aIndex==1:
                    #Collate for Terminal Points
                        for i in range (len(wFilamentTerminalPointsNEWCurrent)):
                            wCompleteTerminalPointsDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsTerminalPointsFilamentClosestDistancePointIndex[i]][0])])])
                            wCompleteTerminalPointsDistAlongFilamentStatALL.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsTerminalPointsFilamentClosestDistancePointIndex[i]][0])])])
    
                            vLabelIndices=list(range(len(wCompleteTerminalPointsDistAlongFilamentStatWorking)))
                            for j in range (len(vLabelIndices)):
                                vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                                              'FilamentIds',
                                                                              str(vFilamentIds[aFilamentIndex]))
                                wLabelListTerminalPoints.append(vLabelCreate)
    
                    if aIndex==2:
                    #Collate for Branch Points
                        for i in range (len(wFilamentBranchPointsNEWCurrent)):
                            wCompleteBranchPointsDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsBranchPointsFilamentClosestDistancePointIndex[i]][0])])])
                            wCompleteBranchPointsDistAlongFilamentStatALL.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsBranchPointsFilamentClosestDistancePointIndex[i]][0])])])
    
                            vLabelIndices=list(range(len(wCompleteBranchPointsDistAlongFilamentStatWorking)))
                            for j in range (len(vLabelIndices)):
                                vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                                              'FilamentIds',
                                                                              str(vFilamentIds[aFilamentIndex]))
                                wLabelListBranchPoints.append(vLabelCreate)
    
            #For  Filament stat
            vNewStatFilamentTerminalPointDistToSomaMax = max(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentTerminalPointDistToSomaMean = mean(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentBranchPointDistToSomaMax = max(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentBranchPointDistToSomaMean = mean(wCompleteTerminalPointsDistAlongFilamentStatWorking)
    
            vNewStatCompleteFilamentBranchPointDistToSomaMean.append(vNewStatFilamentBranchPointDistToSomaMean)
            vNewStatCompleteFilamentTerminalPointDistToSomaMean.append(vNewStatFilamentTerminalPointDistToSomaMean)
    
            vNewStatCompleteFilamentTerminalPointDistToSomaMax.append(vNewStatFilamentTerminalPointDistToSomaMax)
    
            #############################################################
            #Add new Terminal stats
            if qOptionBranchPoints == 1 and qOptionMergePoints == 0:
                vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wFilamentBranchPointsNEWCurrent)
                vSpotsvIds=list(range(len(wFilamentBranchPointsNEWCurrent)))
                vSpotsStatUnits=['um']*len(wFilamentBranchPointsNEWCurrent)
                vSpotsStatFactors=(['Spot']*len(wFilamentBranchPointsNEWCurrent), [str(x) for x in vSpotsTimeIndex] )
                vSpotsStatFactorName=['Category','Time']
                #Create stats for distance along dendrite
                vSpotsStatUnits=['um']*len(wFilamentBranchPointsNEWCurrent)
                vSpotsStatNames=[' Distance to somaalong dendrite']*len(wFilamentBranchPointsNEWCurrent)
                vNewSpotsBranchPointsPerFilament.AddStatistics(vSpotsStatNames, wCompleteBranchPointsDistAlongFilamentStatWorking,
                                              vSpotsStatUnits, vSpotsStatFactors,
                                              vSpotsStatFactorName, vSpotsvIds)
    ########################
            if qOptionTerminalPoints == 1 and qOptionMergePoints == 0:
                vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wFilamentTerminalPointsNEWCurrent)
                vSpotsvIds=list(range(len(wFilamentTerminalPointsNEWCurrent)))
                vSpotsStatUnits=['um']*len(wFilamentTerminalPointsNEWCurrent)
                vSpotsStatFactors=(['Spot']*len(wFilamentTerminalPointsNEWCurrent), [str(x) for x in vSpotsTimeIndex] )
                vSpotsStatFactorName=['Category','Time']
                vSpotsStatNames=[' Distance to soma along dendrite']*len(wFilamentTerminalPointsNEWCurrent)
                vNewSpotsTerminalPointsPerFilament.AddStatistics(vSpotsStatNames, wCompleteTerminalPointsDistAlongFilamentStatWorking,
                                              vSpotsStatUnits, vSpotsStatFactors,
                                              vSpotsStatFactorName, vSpotsvIds)
    
    ###########################
    #Create stats for distance along dendrite to starting point
            vSpotsTimeIndex=[vFilamentsIndexT+1]*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsvIds=list(range(len(vSpotPositionAllShollSpheresPerFilament)))
            vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatFactors=(['Spot']*len(vSpotPositionAllShollSpheresPerFilament), [str(x) for x in vSpotsTimeIndex] )
            vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatNames=[' Distance to Starting Point']*len(vSpotPositionAllShollSpheresPerFilament)
            vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, wCompleteShollSpotDistAlongFilamentStatWorking,
                                          vSpotsStatUnits, vSpotsStatFactors,
                                          vSpotsStatFactorName, vSpotsvIds)
    ################################
            vSpotsStatUnits=['']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatNames=[' Ratio ShollDistance to Distance to Starting Point']*len(vSpotPositionAllShollSpheresPerFilament)
            vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, [vNewStatSpotShollDistance[i]/wCompleteShollSpotDistAlongFilamentStatWorking[i] for i in range(len(vNewStatSpotShollDistance))],
                                          vSpotsStatUnits, vSpotsStatFactors,
                                          vSpotsStatFactorName, vSpotsvIds)
    
    ###############################################################################
    ###############################################################################
    
    #loop for each sphere and create overall stat
        #main loop adds one for last sholl ring
            zShollLabelsInt=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+2), vShollRadius))
            for i in range (len(zShollLabelsInt)):
                if qOptionShollDendrites == 1:
    
                    if zShollLabelsInt[i] < 10:
                        vOverallStatNames = [' Sholl Ring Dendrite Length Sum - ' + '00'+ str(zShollLabelsInt[i]) + ' um']
                    vOverallStatNames = [' Sholl Ring Dendrite Length Sum - ' + '0'+ str(zShollLabelsInt[i]) + ' um']
                    if zShollLabelsInt[i]>=100:
                        vOverallStatNames = [' Sholl Ring Dendrite Length Sum - ' + str(zShollLabelsInt[i]) + ' um']
                    vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentsStatLength[i]],
                                              vOverallStatUnits_um, vOverallStatFactors,
                                              vOverallStatFactorNames, vOverallStatIds)
    
            #Loop just the sholl sphere values
            # if i > 0 and i < len(zShollLabelsInt)-1:
                if i < len(zShollLabelsInt)-1:
    
                    # vOverallStatNames = [' Number Intersections - ' + str(zShollLabelsInt[i]) + ' um Sholl Sphere']
                    # vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNumberOfShollIntersectionPerSpherePerFilament[i-1]],
                    #                           vOverallStatUnits, vOverallStatFactors,
                    #                           vOverallStatFactorNames, vOverallStatIds)
    
                    #Set Sholl sphere Labels for each filament
                    vLabelIndices = (np.where(np.array(vNewStatSpotShollDistance)==zShollLabelsInt[i]))[0].tolist()
                    wLabelList=[]
                    if zShollLabelsInt[i] < 10:
                        zLabelName = ('00' + str(zShollLabelsInt[i]))
                    elif zShollLabelsInt[i] < 100 and zShollLabelsInt[i] >= 10:
                        zLabelName = ('0' + str(zShollLabelsInt[i]))
                    else:
                        zLabelName = str(zShollLabelsInt[i])
    
    
                    for j in range (len(vLabelIndices)):
                        vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j], "Sholl Radius (um)", ' ' + zLabelName)
                        wLabelList.append(vLabelCreate)
                    vNewShollSpotsPerFilament.SetLabels(wLabelList)
    
    
    ###############################################################################
    ###############################################################################
    #Calcualte Arbor Orientation Index
    #Equation:
    #    AOE = (Number of Shollpoints in vertical Quadrants -Number of Shollpoints in horizaontal Quadrants) / Total Numerb of Sholl points
    #AOE =  1  vertically aligned
    #AOE = -1  horizontally aligned
    #AOE =  0 are equal in all directions
    #     vSpotPositionAllShollSpheresPerFilamentAdjusted=[vSpotPositionAllShollSpheresPerFilament[i] - vBeginningVertexPositionXYZ
    #                                                      for i in range(len(vSpotPositionAllShollSpheresPerFilament))]
    
    #Use a reference frame to set the orientation space to measure from
    #Extract out the sholl position relative to the Ref Frame
    #zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Segment Position X Reference frame').mValues
    #zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Segment Position Y Reference frame').mValues
    #zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Segment Position Z Reference frame').mValues
    
    
    
    
    #If refernce is set to orient the orign axis
        #Grab New Filament Spine Statistics for attachment point distance.
        # vNewShollSpotsPerFilamentStatistics = vNewSpots.GetStatistics()
        # vNewShollSpotsPerFilamentStatNames = vNewShollSpotsPerFilamentStatistics.mNames
        # vNewShollSpotsPerFilamentStatValues = vNewShollSpotsPerFilamentStatistics.mValues
        # vNewShollSpotsPerFilamentStatIds = vNewShollSpotsPerFilamentStatistics.mIds
    
    
    
    #Maybe something different for 3D Sholl???
    
    
    
    
    ###############################################################################
    ###############################################################################
    #Calculate Convexhull and Delauney 2d and 3D
    #convert xyz position into closest pixel coordinates
        wConversionX = (vDataMax[0]-vDataMin[0])/vDataSize[0]
        wConversionY = (vDataMax[1]-vDataMin[1])/vDataSize[1]
        wConversionZ = (vDataMax[2]-vDataMin[2])/vDataSize[2]
        if qOptionConvexHull == 1:
    
            if qOptionConvexHullTerminal == 1:
                vFilamentXYZPointsConvexHullPixelPos = np.copy(wFilamentTerminalPointsNEWCurrent)
                vFilamentXYZPointsConvexHullPixelPos = np.vstack([vFilamentXYZPointsConvexHullPixelPos, wFilamentStartingPointsNEWCurrent])
                vFilamentsXYZArray = np.array(vFilamentXYZPointsConvexHullPixelPos)
            else:
                vFilamentsXYZArray = np.array(vFilamentsXYZ)
                vFilamentXYZPointsConvexHullPixelPos = np.copy(vFilamentsXYZArray)
    
            vFilamentXYZPointsConvexHullPixelPos[:,0] = (vFilamentXYZPointsConvexHullPixelPos[:,0]-vDataMin[0])/wConversionX
            vFilamentXYZPointsConvexHullPixelPos[:,1] = (vFilamentXYZPointsConvexHullPixelPos[:,1]-vDataMin[1])/wConversionY
            vFilamentXYZPointsConvexHullPixelPos[:,2] = (vFilamentXYZPointsConvexHullPixelPos[:,2]-vDataMin[2])/wConversionZ
            vFilamentXYZPointsConvexHullPixelPos = vFilamentXYZPointsConvexHullPixelPos.astype(int)
    
            vFilamentXYZPointsConvexHullPixelPos[:,0][np.where(vFilamentXYZPointsConvexHullPixelPos[:,0] == vDataSize[0])[0]]=vDataSize[0]-1
            vFilamentXYZPointsConvexHullPixelPos[:,1][np.where(vFilamentXYZPointsConvexHullPixelPos[:,1] == vDataSize[1])[0]]=vDataSize[1]-1
            # vFilamentXYZPointsConvexHullPixelPos[:,2][np.where(vFilamentXYZPointsConvexHullPixelPos[:,2] == vDataSize[2])[0]]=vDataSize[2]-1
    
            #Test is volume is 2D
            if vDataSize[2] == 1:
                #for stat calculation
                vFilamentsXYZArray2D = np.delete(vFilamentsXYZArray,2,1)
                wFilamentConvexHullCurrentStat = ConvexHull(vFilamentsXYZArray2D)
    
                vFilamentXYZPointsCurrentPixelPos2D = np.delete(vFilamentXYZPointsConvexHullPixelPos,2,1)
                wFilamentConvexHullCurrent = ConvexHull(vFilamentXYZPointsCurrentPixelPos2D)
                wFilamentConvexHullDelaunyCurrent = Delaunay(vFilamentXYZPointsCurrentPixelPos2D[wFilamentConvexHullCurrent.vertices])
    
            else:
                wFilamentConvexHullCurrentStat = ConvexHull(vFilamentsXYZArray)
    
        #Calculate Dendritic Field Size (2D and 3D) and surface area...from ConvexHull
            wNewStatConvexHullVolumePerFilament.append(wFilamentConvexHullCurrentStat.volume)
            wNewStatConvexHullAreaPerFilament.append(wFilamentConvexHullCurrentStat.area)
    
            progress_bar2['value'] = int((aFilamentIndex+.5)/vNumberOfFilaments*100) #  % out of 100
            qProgressBar.update()
    
        #create new Dataset full volume
            vDataSet = vImarisApplication.GetFactory().CreateDataSet()
            vDataSet.Create(vType, vDataSize[0], vDataSize[1], vDataSize[2], 1, 1)
            vDataSet.SetExtendMinX(vDataMin[0])
            vDataSet.SetExtendMinY(vDataMin[1])
            vDataSet.SetExtendMinZ(vDataMin[2])
            vDataSet.SetExtendMaxX(vDataMax[0])
            vDataSet.SetExtendMaxY(vDataMax[1])
            vDataSet.SetExtendMaxZ(vDataMax[2])
            vDataSet.SetTimePoint(vFilamentsIndexT, vFilamentTimepoint)
    
        #Create Convex hull mask and generate surface
            if vDataSize[2] == 1:
                #for 2D whole image
                idx = np.stack(np.indices([vDataSize[0],vDataSize[1]]), axis = -1)
                out_idx = np.nonzero(wFilamentConvexHullDelaunyCurrent.find_simplex(idx) + 1)
                vSlice = np.zeros([vDataSize[0],vDataSize[1]])
                vSlice[out_idx] = 1
                #convert to single column per slice for import into Channel
                vSlice = vSlice.flatten('F')
                vIndexZ=0
                #Add mask to DataSet
                vDataSet.SetDataSubVolumeAs1DArrayFloats(vSlice.tolist(),
                                                0,
                                                0,
                                                vIndexZ,
                                                0,
                                                0,
                                                vDataSize[0],
                                                vDataSize[1],
                                                1)
            else:
                #create tuple and flip so that Z is first column, follow by x ,then Y
                points = tuple((vFilamentXYZPointsConvexHullPixelPos[:,2],
                               vFilamentXYZPointsConvexHullPixelPos[:,0],
                               vFilamentXYZPointsConvexHullPixelPos[:,1]))
                image = np.zeros((vDataSize[2],vDataSize[0],vDataSize[1]))
    
                #Replace Points in blank image for COnvexHull calculation
                image[points] = 1
                #Find Indices in volume where value is >1
                points = np.transpose(np.where(image))
                #Process COnvex hull and Delauney
                hull = ConvexHull(points)
                deln = Delaunay(points[hull.vertices])
                vVolume = np.zeros((vDataSize[2],vDataSize[0],vDataSize[1]))
                #for 3D whole image
                idx = np.stack(np.indices(vVolume.shape), axis = -1)
                out_idx = np.nonzero(deln.find_simplex(idx) + 1)
                #Set value=1 for pixels inside Convexhull
                vVolume[out_idx] = 1
    
                #loop each Z and creat Convexhull mask channel
                for vIndexZ in range (vDataSize[2]):
                    vSlice = vVolume[vIndexZ].flatten('F')
                    #Add mask to DataSet
                    vDataSet.SetDataSubVolumeAs1DArrayFloats(vSlice.tolist(),
                                                    0,
                                                    0,
                                                    vIndexZ,
                                                    0,
                                                    0,
                                                    vDataSize[0],
                                                    vDataSize[1],
                                                    1)
                    progress_bar3['value'] = int((vIndexZ)/vDataSize[2]*100) #  % out of 100
                    qProgressBar.update()
        #make surface convex hull
            ip = vImarisApplication.GetImageProcessing()
            vConvexHull = ip.DetectSurfaces(vDataSet, [],
                                      0,
                                      vSmoothingFactor,
                                      0,
                                      True,
                                      55,
                                      '')
      #copy surface to sceneobject named vSurfaceHull
            vConvexHull.CopySurfacesToSurfaces([0], vSurfaceHull)
    
    ##############################################################################
    ###############################################################################
        if qOptionRegularityIndex == 1:
        #Calculation of Mean Nearest Neighbor based on branch points and terminal points
            #Create a set of Random Spots, same numebr of branch points or terminal points
            #limit creation of random spot to be within the MinMax of XYZ of the filament points
            zArray=np.array(vFilamentsXYZ)
            isFilament2D=False
            zRandomLimitsMin=np.min(zArray, 0)
            zRandomLimitsMax=np.max(zArray, 0)
            zRandomSpotsTerminal=[]
            zRandomSpotsNode=[]
            zAverageNNBranchPointRandomALL = []
            zAverageNNTerminaTPointRandomALL=[]
            zCurrentFilamentsRegularityIndexTP = []
            zCurrentFilamentsRegularityIndexBP = []
    
            if len(wFilamentBranchPointsNEWCurrent) > 3:
            # if np.shape(wFilamentBranchPoints)[0] >3:
                zArrayNodes=cdist(wFilamentBranchPointsNEWCurrent,wFilamentBranchPointsNEWCurrent)
                zArrayNodesMin=np.where(zArrayNodes>0, zArrayNodes, np.inf).min(axis=1)
                zMeanNNBranchPoint=np.mean(zArrayNodesMin)
                for iRandom in range (10):
                    zRandomSpotsNode=[]
                    for i in range(3):
                        zRandomSpotsNode.append(np.random.uniform(low=zRandomLimitsMin[i], high=zRandomLimitsMax[i], size= np.shape(wFilamentBranchPointsNEWCurrent)[0]))
                    zRandomSpotsNode=np.transpose(np.array(zRandomSpotsNode))
                    #Find if set of Random Spots falls inside Convex hull on Filament
                    if (np.all(zArray[:,2] == zArray[0][2]))==True:
                        zArray=np.delete(zArray,2,1)
                        zRandomSpotsNode=np.delete(zRandomSpotsNode,2,1)
                        isFilament2D=True
                    zHullDelaunay = Delaunay(zArray)
                    #Create Boolean arguement to define if in Convex hull
                    zRandomSpotTestNode=np.array(zHullDelaunay.find_simplex(zRandomSpotsNode)>=0)
                    #Keep True, replace false with new random spot
                    if np.any(zRandomSpotTestNode):
                        #find indices that are True
                        zBrokenRandomSpots=np.where(zRandomSpotTestNode==False)
                        for i in range (len(zBrokenRandomSpots)):
                            #Create new random spot
                            zNEWRandomSpot=[]
                            for j in range(3):
                                zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                            zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                            if isFilament2D:
                                zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Test if inConvex hull
                            while (zHullDelaunay.find_simplex(zNEWRandomSpot)>=0)==False:
                                #Create new random spot
                                zNEWRandomSpot=[]
                                for j in range(3):
                                    zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                                zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                                if isFilament2D:
                                    zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Replace entire row with new positions
                            zRandomSpotsNode[zBrokenRandomSpots[0][i],:]=zNEWRandomSpot
                    #Calculation of Mean Nearest Neighbor based on branch points and terminal points
                    zArrayNodes=cdist(zRandomSpotsNode,zRandomSpotsNode)
                    zArrayNodesMin=np.where(zArrayNodes>0, zArrayNodes, np.inf).min(axis=1)
                    zAverageNNBranchPointRandom=np.mean(zArrayNodesMin)
    
                    #Collate all NN from the 10 random rounds....
                    zAverageNNBranchPointRandomALL.append(zAverageNNBranchPointRandom)
                #Calculation of Regulatiry Index
                zAllFilamentsRegularityIndexBP.append(zMeanNNBranchPoint/mean(zAverageNNBranchPointRandomALL))
                zCurrentFilamentsRegularityIndexBP.append(zMeanNNBranchPoint/mean(zAverageNNBranchPointRandomALL))
    
            else:
                zAllFilamentsRegularityIndexBP.append(0)
                zCurrentFilamentsRegularityIndexBP.append(0)
        ###############################################################################
            if len(wFilamentTerminalPointsNEWCurrent) > 3:
            # if np.shape(wFilamentTerminalPointsNEWCurrent)[0] >3:
                zArrayTerminal=cdist(wFilamentTerminalPointsNEWCurrent,wFilamentTerminalPointsNEWCurrent)
                zArrayTerminalMin=np.where(zArrayTerminal>0, zArrayTerminal, np.inf).min(axis=1)
                zMeanNNTerminalPoint=np.mean(zArrayTerminalMin)
                for iRandom in range (10):
                    zRandomSpotsTerminal=[]
                    for i in range(3):
                        zRandomSpotsTerminal.append(np.random.uniform(low=zRandomLimitsMin[i], high=zRandomLimitsMax[i], size= np.shape(wFilamentTerminalPointsNEWCurrent)[0]))
                    zRandomSpotsTerminal=np.transpose(np.array(zRandomSpotsTerminal))
                    #Find if set of Random Spots falls inside Convex hull on Filament
                    if (np.all(zArray[:,2] == zArray[0][2]))==True:
                        zArray=np.delete(zArray,2,1)
                        zRandomSpotsTerminal=np.delete(zRandomSpotsTerminal,2,1)
                        isFilament2D=True
                    zHullDelaunay = Delaunay(zArray)
                    #Create Boolean arguement to define if in Convex hull
                    zRandomSpotTestTerminal=np.array(zHullDelaunay.find_simplex(zRandomSpotsTerminal)>=0)
                    if np.any(zRandomSpotTestTerminal):
                        #find indices that are True
                        zBrokenRandomSpots=np.where(zRandomSpotTestTerminal==False)
                        for i in range (len(zBrokenRandomSpots)):
                            #Create new random spot
                            zNEWRandomSpot=[]
                            for j in range(3):
                                zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                            zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                            if isFilament2D:
                                zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Test if inConvex hull
                            while (zHullDelaunay.find_simplex(zNEWRandomSpot)>=0)==False:
                                #Create new random spot
                                zNEWRandomSpot=[]
                                for j in range(3):
                                    zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                                zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                                if isFilament2D:
                                    zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Replace entire row with new positions
                            zRandomSpotsTerminal[zBrokenRandomSpots[0][i],:]=zNEWRandomSpot
                    #Calculation of Mean Nearest Neighbor based on branch points and terminal points
                    zArrayTerminal=cdist(zRandomSpotsTerminal,zRandomSpotsTerminal)
                    zArrayTerminalMin=np.where(zArrayTerminal>0, zArrayTerminal, np.inf).min(axis=1)
                    zAverageNNTerminaTPointRandom=np.mean(zArrayTerminalMin)
                    #Collate all NN from the 10 random rounds....
                    zAverageNNTerminaTPointRandomALL.append(zAverageNNTerminaTPointRandom)
                #Calculation of Regulatiry Index
                zAllFilamentsRegularityIndexTP.append(zMeanNNTerminalPoint/mean(zAverageNNTerminaTPointRandomALL))
                zCurrentFilamentsRegularityIndexTP.append(zMeanNNTerminalPoint/mean(zAverageNNTerminaTPointRandomALL))
            else:
                zAllFilamentsRegularityIndexTP.append(0)
                zCurrentFilamentsRegularityIndexTP.append(0)
    
            if len(wFilamentBranchPointsNEWCurrent) > 3 and qOptionBranchPoints == 1:
                vOverallStatNames = [' Dendrite Regularity Index - BranchPoints']
                vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, zCurrentFilamentsRegularityIndexBP,
                                                        vOverallStatUnits, vOverallStatFactors,
                                                        vOverallStatFactorNames, vOverallStatIds)
            if len(wFilamentTerminalPointsNEWCurrent) > 3 and qOptionTerminalPoints == 1:
                vOverallStatNames = [' Dendrite Regularity Index - TerminalPoints']
                vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, zCurrentFilamentsRegularityIndexTP,
                                                        vOverallStatUnits, vOverallStatFactors,
                                                        vOverallStatFactorNames, vOverallStatIds)
            if len(wFilamentTerminalPointsNEWCurrent) > 3 and qOptionTerminalPoints == 1:
                vOverallStatNames = [' Dendrite Complexity Index (DCI) ']
                vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [wFilamentComplexityIndexCurrent],
                                                        vOverallStatUnits, vOverallStatFactors,
                                                        vOverallStatFactorNames, vOverallStatIds)
    
        #populated the Toruosity stat
        # vNewStatTortuosityPerFilament.append(np.mean(np.array(vNewStatTortuosityPerSegment)[np.where(np.array(vNewStatTortuosityPerSegment)>0)]))
    
    ###############################################################################
    #Reset Spots for next filament
        wCompleteDendriteTimeIndex.extend([vFilamentsIndexT+1]*len(wSegmentIdsALL))
        wCompleteFilamentTimeIndex.extend([vFilamentsIndexT+1]*vFilamentCountActual)
        wCompeteSegmentBranchDepthPerFilament.append(vSegmentBranchDepthCurrent)
    
        vNewStatSpotNumberShollIntersections=[]
        vNewStatSpotShollDistance=[]
        vSpotPositionAllShollSpheresPerFilament=[]
        vNumberOfShollIntersectionPerSpherePerFilament=[]
    ###############################################################################
    ###############################################################################
        progress_bar2['value'] = int((aFilamentIndex+1)/vNumberOfFilaments*100) #  % out of 100
        qProgressBar.update()
    
    ###############################################################################
    #Add dendrite level statistics for each segment with length value
    vFilamentStatvIds=list(range(len(vAllFilamentDendriteLengthIds)))
    vFilamentStatUnits=['']*len(vAllFilamentDendriteLengthIds)
    
    if aVersionValue < 10:
        vFilamentStatFactors=(['Segment']*len(vAllFilamentDendriteLengthIds), [str(x) for x in wCompleteDendriteTimeIndex] )
    else:
        vFilamentStatFactors=(['Dendrite']*len(vAllFilamentDendriteLengthIds), [str(x) for x in wCompleteDendriteTimeIndex] )
    vFilamentStatFactorName=['Category','Time']
    ########################
    
    
    
    # #Tortuosity
    # vFilamentStatNames=[' Dendrite Tortuosity ']*(len(vAllFilamentDendriteLengthIds))
    # vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteTortuosityPerSegment,
    #                       vFilamentStatUnits, vFilamentStatFactors,
    #                       vFilamentStatFactorName, wSegmentIdsALL)
    
    # vNewStatCompleteTortuosityPerSegmentSumPerum=[vNewStatCompleteTortuosityPerSegmentSum[i] / vAllFilamentDendriteLength[i] for i in range(len(vAllFilamentDendriteLength))]
    # vFilamentStatNames=[' Dendrite Tortuosity Sum ']*(len(vAllFilamentDendriteLengthIds))
    # vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteTortuosityPerSegmentSum,
    #                       vFilamentStatUnits, vFilamentStatFactors,
    #                       vFilamentStatFactorName, wSegmentIdsALL)
    
    #########################
    #########################
    #Produce Report the Filament level stats
    vFilamentStatUnits=['']*vFilamentCountActual
    vFilamentStatFactors=(['Filament']*vFilamentCountActual, [str(x) for x in wCompleteFilamentTimeIndex] )
    vFilamentStatFactorName=['Category','Time']
    vFilamentStatNames=[' Filament - Tortuosity']*vFilamentCountActual
    # vFilaments.AddStatistics(vFilamentStatNames, vNewStatTortuosityPerFilament,
    #                           vFilamentStatUnits, vFilamentStatFactors,
    #                           vFilamentStatFactorName, vFilamentIds)
    ########################
    #Mean distance to Terminal Point
    vFilamentStatNames=[' Filament - TerminalPoint Mean Distance to soma ']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteFilamentTerminalPointDistToSomaMean,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, vFilamentIds)
    ########################
    #Max distance to Terminal Point
    vFilamentStatNames=[' Filament - TerminalPoint Max Distance to soma ']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteFilamentTerminalPointDistToSomaMax,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, vFilamentIds)
    ########################
    #Filament Dendrite Complexity Index
    vFilamentStatNames=[' Filament - Dendrite Complexity Index (DCI) ']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, wFilamentComplexityIndexComplete,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, vFilamentIds)
    
    ########################
    if qOptionRegularityIndex == 1:
        #Filament RegularityIndex
        vFilamentStatNames=[' Filament - Dendrite Regularity Index (DRI) Terminal']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, zAllFilamentsRegularityIndexTP,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)
        ########################
        #Filament RegularityIndex
        vFilamentStatNames=[' Filament - Dendrite Regularity Index (DRI) Branch']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, zAllFilamentsRegularityIndexBP,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)
    
    if qOptionConvexHull == 1:
        if vDataSize[2]==1:
            vFilamentStatNames=[' Filament - Dendritic Field Area (um^2)(convexhull)']*vFilamentCountActual
        else:
            vFilamentStatNames=[' Filament - Dendritic Field Volume (um^3)(convexhull)']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, wNewStatConvexHullVolumePerFilament,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)
    
        if vDataSize[2]==1:
            vFilamentStatNames=[' Filament - Dendritic Field Perimeter (um)(convexhull)']*vFilamentCountActual
        else:
            vFilamentStatNames=[' Filament - Dendritic Field SurfaceArea (um^2)(convexhull)']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, wNewStatConvexHullAreaPerFilament,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)
    
    
    ###################################
    #Create Branch points for all filaments and create labels for branch point classification
    if qOptionBranchPoints == 1 and qOptionMergePoints == 1:
        #Create Spots for all Branch Points
        vNewSpotsBranchPointsPerFilamentComplete = vImarisApplication.GetFactory().CreateSpots()
        vNewSpotsBranchPointsPerFilamentComplete.Set(wFilamentBranchPointsComplete,
                              [vFilamentsIndexT]*len(wFilamentBranchPointsComplete),
                              [1]*len(wFilamentBranchPointsComplete))
        vNewSpotsBranchPointsPerFilamentComplete.SetName(' BranchPoints - ALL:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewSpotsBranchPointsPerFilamentComplete.SetColorRGBA(zRandomColor)#Set Random color
        vSpotFilamentPoints.AddChild(vNewSpotsBranchPointsPerFilamentComplete, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)
    ############
        #Add new stat to each branch point
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vSpotsvIds=list(range(len(wCompleteBranchPointsDistAlongFilamentStatALL)))
        vSpotsStatUnits=['um']*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vSpotsStatFactors=(['Spot']*len(wCompleteBranchPointsDistAlongFilamentStatALL), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        vSpotsStatNames=[' Distance to soma along dendrites']*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vNewSpotsBranchPointsPerFilamentComplete.AddStatistics(vSpotsStatNames, wCompleteBranchPointsDistAlongFilamentStatALL,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)
    
    
    ############
        #Create Labels for the branch points
        vLabelIndices=list(range(len(wFilamentBranchPointsComplete)))
        wLabelList=[]
        wLabelName = ('Arborization','Continuation', 'Termination')
        for i in range (3):
            wLabelList=[]
            for j in range (len(vLabelIndices)):
                if vNodeTypesComplete[j] == i:
                    vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                          'Classified Nodes',
                                                          'FilamentId-' + str(vNodeFilamentIdsComplete[j]) + '--' + str(wLabelName[vNodeTypesComplete[j]]))
                    wLabelList.append(vLabelCreate)
            vNewSpotsBranchPointsPerFilamentComplete.SetLabels(wLabelList)
    
        vNewSpotsBranchPointsPerFilamentComplete.SetLabels(wLabelListBranchPoints)
    
    
    if qOptionTerminalPoints == 1 and qOptionMergePoints == 1:
        vNewSpotsTerminalPointsPerFilamentComplete = vImarisApplication.GetFactory().CreateSpots()
        vNewSpotsTerminalPointsPerFilamentComplete.Set(wFilamentTerminalPointsComplete,
                              [vFilamentsIndexT]*len(wFilamentTerminalPointsComplete),
                              [1]*len(wFilamentTerminalPointsComplete))
        vNewSpotsTerminalPointsPerFilamentComplete.SetName(' TerminalPoints - ALL:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewSpotsTerminalPointsPerFilamentComplete.SetColorRGBA(zRandomColor)#Set Random color
        vSpotFilamentPoints.AddChild(vNewSpotsTerminalPointsPerFilamentComplete, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)
    
    ############
        #Add new stat to each terminal point
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vSpotsvIds=list(range(len(wCompleteTerminalPointsDistAlongFilamentStatALL)))
        vSpotsStatUnits=['um']*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vSpotsStatFactors=(['Spot']*len(wCompleteTerminalPointsDistAlongFilamentStatALL), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        vSpotsStatNames=[' Distance to soma along dendrites']*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vNewSpotsTerminalPointsPerFilamentComplete.AddStatistics(vSpotsStatNames, wCompleteTerminalPointsDistAlongFilamentStatALL,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)
    
    ############
    #Create Labels for the terminal points
        vNewSpotsTerminalPointsPerFilamentComplete.SetLabels(wLabelListTerminalPoints)
    
    
    
    #Sholl Branching Density
    #Make series of fixed (randomly placed lines/planes in the volume)
    #Quantify the number of Sholl Intersections with these lines
    #Report NumberIntersections/um
    
    #Alternative:  create convexhull around terminal points, make sure the lines
    # fall inside of the convex hull
    
    ###############################################################################
    
    
    
    ##############################################################################
    #Visibility of the Scene Objects
    # vSpotFilamentPoints.SetVisible(0)
    
    
    ##############################################################################
    #Add Convex Hull surfaces
    if qOptionConvexHull == 1:
        vSurfaceHull.SetName('Filament ConvexHull Surfaces')
        vSurfaceHull.SetColorRGBA(vFilaments.GetColorRGBA())
    
        # #Add new surface convex hull folder
        vSurfaceConvexHull.AddChild(vSurfaceHull, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSurfaceConvexHull, -1)
    
        #Create Labels for Convex hull surfaces to match filament ID
        vLabelIndices=list(range(vFilamentCountActual))
        wLabelList=[]
        for j in range (len(vLabelIndices)):
            vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                      'FilamentIds',
                                                      str(vFilamentIds[j]))
            wLabelList.append(vLabelCreate)
        vSurfaceHull.SetLabels(wLabelList)
    
    
    ################
    #Add Surface labels for ConvexHull with FilamentID as name
    #NEED to do this
    
    
    
    ##############################################################################
    vFilaments.SetName(vFilaments.GetName()+' -- Analyzed')
    vImarisApplication.GetSurpassScene().AddChild(vFilaments, -1)
    
    qProgressBar.destroy()
    qProgressBar.mainloop()