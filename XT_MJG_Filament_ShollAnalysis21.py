# Filament Sholl Analysis
#
# Written by Matthew J. Gastinger
#
# March 2023 - Imaris 10
#
# ---  Updates:
#   1. Adding a new feature to segment dendrites within each Sholl sphere
#   2. Improving the multi-Filament functionality
#
#
    #<CustomTools>
        #<Menu>
            #<Submenu name="Filaments Functions">
                #<Item name="Filament Sholl Analysis21" icon="Python3">
                    #<Command>Python3XT::XT_MJG_Filament_ShollAnalysis21(%i)</Command>
                #</Item>
            #</Submenu>
       #</Menu>
       #<SurpassTab>
           #<SurpassComponent name="bpFilaments">
               #<Item name="Filament Sholl Analysis21" icon="Python3">
                   #<Command>Python3XT::XT_MJG_Filament_ShollAnalysis21(%i)</Command>
               #</SurpassComponent>
           #</SurpassTab>
    #</CustomTools>


# Description:
#
# Finds and displays Sholl intersections for each Filament that has been traced
# and contains a Starting Point.  Works for both single and multiple filaments.
# Sholl sphere radius is defined by the user.  Each dendrite segments is
# quantified that crosses these intervals at least once.


# RESULTS:
# 1.	 Advanced Sholl Analysis
#         - A Group folder is generated.
#         - Each valid filament will generate a Spots object (named using original FilamentID)
#             and is set with a custom label for each Sholl Radius.
#         -A New Label is generated for each Sholl intersection
#     ---Overall Statistics Tab
#         i.   Critical Radius (um)
#                 ---Sholl distance with the maximum number of intersections from the defined Sholl intervals
#         ii.  Max # Intersections
#                 ---Maximum Number of Intersections at the Critical Radius
#         iii. Critical Radius HighRes (um)
#                 ---Sholl distance with the maximum number of intersections using 1um Sholl Radius
#         iv.  Max # Intersections HighRes
#                 ---Maximum Number of Intersections at the Critical Radius HighRes
#         v.   Dendrite Length Sum
#                   ---Cumulative Sum of all dendrite segments that fall within the
#                     boundaries of the Sholl Spheres (i.e. 10 um Sholl Ring
#                     quantifies dendrites between 0 and 10 um from Starting Point
#         vi.   Regularity Index (Branch and Terminal points)
#                   ---Calculation of Mean Nearest Neighbor based on branch points and terminal points
#                   ---Create a set of Random Spots (10times), same number of branch points or terminal points
#                       ---limit creation of random spots to be within the Convexhull of the filament
#                   ---RegularityIndex is (meanNN)/(meanNN of Random spots)
#                       ---ratio close to 1 indicates random distribution
#                       ---ratio further from 1 indicates ordered array
#         vii.   Dendritic Field Volume and Dendrite Field Surface area per filament
#                   ---Calculated from convexhull generated by the all terminal points and starting point
#                   ---if 2D, Volume is cross-sectional area
#                   ---if 2D, SurfaceArea is perimeter
#         viii.  Filament - TerminalPoint Mean Distance to soma
#           ix.  Filament - TerminalPoint Max Distance to soma
#            x.  Filament - TerminalPoint Mean Distance along dendrite to soma
#           xi.  Filament - TerminalPoint Max Distance along dendrite to soma

#     ---Detailed Statistics Tab
#         i. Shortest Distance to Starting Point
#                 ---Measures the distance of the Sholl Intersection point to the starting point along the dendrite path
#                         ---Smaller values are closer to the soma
#         ii. Ratio ShollDistance to Distance to Starting Point
#                 ---Values close to “1” correlate highly to Sholl Radius distance
#                 ---Values far from “1” likely possess a non-direct line to soma

# 2.	Sholl Dendrites
#         -A new filament object is created that splits the filament object at each Sholl intersection.
#            --Spilts the the segment by "deleting a single point at Sholl intersection
#             This is primarily used for visualization purposes.
#             ---Each Dendrite is classified and visualized using a
#                 statistics-coded custom statistic for “Sholl Sphere”

# This is not an exact replica of the Sholl intersections reported by the
# Filament object (built into Imaris).  The values are very similar, but the rules
# for identifying a single intersection differ slightly, especially
# around where a branch point intersects a Sholl sphere. (See Readme.doc for
# an report of comparison)


import time
import random
import platform
import math

# GUI imports
# GUI imports
import tkinter as tk
from tkinter import ttk
from tkinter.ttk import *
from tkinter import *
from tkinter import messagebox
from tkinter import simpledialog
from operator import add
from operator import itemgetter
import operator
import itertools
from statistics import mean
from functools import reduce
import collections
import matplotlib.pyplot as plt


import ImarisLib
# import matplotlib.pyplot as plt
from scipy import stats
from scipy.signal import find_peaks
from scipy.signal import peak_widths
from scipy.spatial.distance import cdist
from scipy.spatial.distance import pdist
from scipy.spatial import Delaunay
from scipy.spatial import ConvexHull

from numpy import array
import numpy as np

aImarisId=0
def XT_MJG_Filament_ShollAnalysis21(aImarisId):
    # Create an ImarisLib object
    vImarisLib = ImarisLib.ImarisLib()
    # Get an imaris object with id aImarisId
    vImarisApplication = vImarisLib.GetApplication(aImarisId)
    # Get the factory
    vFactory = vImarisApplication.GetFactory()
    # Get the currently loaded dataset
    vImage = vImarisApplication.GetDataSet()
    # Get the Surpass scene
    vSurpassScene = vImarisApplication.GetSurpassScene()

    vFilaments = vFactory.ToFilaments(vImarisApplication.GetSurpassSelection())

    #Create a new folder object for new Sholl Spot intersections
    vNew_Spots = vImarisApplication.GetFactory()
    result2 = vNew_Spots.CreateDataContainer()
    result2.SetName('Sholl Intersections - ' + str(vFilaments.GetName))
    #Old Imaris Version
    aVersionValue = 9.9

    ##################################################################
    ##################################################################
    def ShollInput ():
        global vShollRadius,qSplitShollspheres, qOptionTerminalPoints, qOptionBranchPoints
        global qOptionShollDendrites, qOptionMergePoints, qOptionRegularityIndex
        global qOptionConvexHullTerminal, qOptionConvexHull
        qSplitShollspheres=var1.get()
        qOptionBranchPoints = var2.get()
        qOptionTerminalPoints = var3.get()
        qOptionMergePoints = var22.get()
        qOptionShollDendrites = var4.get()
        qOptionRegularityIndex = var5.get()
        qOptionConvexHull = var6.get()
        qOptionConvexHullTerminal = var7.get()


        vShollRadius=Entry1.get()
        vShollRadius=int(vShollRadius)
        qInputBox.destroy()

    qInputBox=Tk()
    qInputBox.title("Advanced Dendrite Analysis")
    qInputBox.geometry("500x460")
    qInputBox.attributes("-topmost", True)

    var1 = tk.IntVar(value=0)
    var2 = tk.IntVar(value=0)
    var22 = tk.IntVar(value=1)
    var3 = tk.IntVar(value=0)
    var4 = tk.IntVar(value=0)
    var5 = tk.IntVar(value=0)
    var6 = tk.IntVar(value=1)
    var7 = tk.IntVar(value=0)


    Label(qInputBox,text="Sholl Sphere Radius (um):").grid(row=0, column=0, sticky=E)
    ##################################################################
    # Set Input Window to center of screen
    # Gets the requested values of the height and widht.
    windowWidth = qInputBox.winfo_reqwidth()
    windowHeight = qInputBox.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(qInputBox.winfo_screenwidth()/2 - windowWidth/2)
    positionDown = int(qInputBox.winfo_screenheight()/2 - windowHeight/2)
    # Positions the window in the center of the page.
    qInputBox.geometry("+{}+{}".format(positionRight, positionDown))
    ##################################################################
    Entry1=Entry(qInputBox,justify='center',width=7)
    Entry1.grid(row=0, column=1, sticky=W)
    Entry1.insert(0, 10)

    # tk.Label(qInputBox, text='*Always calculates Sholl').grid(row=0, column=1)



    tk.Checkbutton(qInputBox, text='Create Spots Objects \n'
                   'per Sholl sphere',
                   variable=var1, onvalue=1, offvalue=0).grid(row=2, column=1,)
    tk.Checkbutton(qInputBox, text='Quantify Dendrite Lengths\n'
                                   'per Sholl sphere',
                   variable=var4, onvalue=1, offvalue=0).grid(row=2, column=0, padx=20)

    tk.Label(qInputBox, text='____________________________________').grid(row=4, column=0)

    tk.Checkbutton(qInputBox, text='Branch Point Analysis',
                   variable=var2, onvalue=1, offvalue=0).grid(row=5, column=0, sticky=W)
    tk.Checkbutton(qInputBox, text='Merge',
                    variable=var22, onvalue=1, offvalue=0).grid(row=5, column=1, sticky=W)
    tk.Checkbutton(qInputBox, text='Terminal Point Analysis',
                   variable=var3, onvalue=1, offvalue=0).grid(row=6, column=0, sticky=W)

    tk.Checkbutton(qInputBox, text='Calculate Regularity Index (Terminal/Branch)\n'
                                       '(meanNN/RandomMeanNN)',
                   variable=var5, onvalue=1, offvalue=0).grid(row=7, column=0,sticky=W)
    tk.Label(qInputBox, text='____________________________________').grid(row=8, column=0)



    tk.Checkbutton(qInputBox, text='Create ConvexHull surface (Dendritic Field)',
                   variable=var6, onvalue=1, offvalue=0).grid(row=9, column=0,sticky=W)
    tk.Checkbutton(qInputBox, text='Use Terminal Points',
                   variable=var7, onvalue=1, offvalue=0).grid(row=10, column=0,sticky=W, padx=30)



    qWhatOS = platform.system()
    if qWhatOS == 'Darwin':
        Single=Button(qInputBox, text="Process Sholl Analysis",command=ShollInput )
    else:
        Single=Button(qInputBox, bg="blue", fg="white", text="Process Dendrite Analysis",command=ShollInput )
    Single.grid(row=10, column=1, sticky=W)

    tk.Label(qInputBox, text='************************************').grid(row=11, column=0,sticky=W)
    tk.Label(qInputBox, text='--Number Sholl Intersections').grid(row=12, column=0,sticky=W)
    tk.Label(qInputBox, text='--Critical Radius').grid(row=13, column=0,sticky=W)
    tk.Label(qInputBox, text='--Max # Intersections').grid(row=14, column=0,sticky=W)
    tk.Label(qInputBox, text='--Dendrite Length Sum').grid(row=15, column=0,sticky=W)
    tk.Label(qInputBox, text='--Critcal Radius Dendrite Length Sum').grid(row=16, column=0,sticky=W)

    tk.Label(qInputBox, text='************************************').grid(row=11, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendritic Field (Volume/Area)').grid(row=12, column=1,sticky=W)
    tk.Label(qInputBox, text='--Dendritic Field (SurfaceArea/Perimeter)').grid(row=13, column=1,sticky=W)
    tk.Label(qInputBox, text='--Mean Distance TerminalPoints to Soma').grid(row=14, column=1,sticky=W)
    tk.Label(qInputBox, text='--Max Distance TerminalPoints to Soma').grid(row=15, column=1,sticky=W)
    tk.Label(qInputBox, text='--BranchPoint Classifications').grid(row=16, column=1,sticky=W)




    qInputBox.mainloop()
    ##################################################################
    ##################################################################
    #Create the Progress bars
    #Creating a separate Tkinter qProgressBar for progress bars
    qProgressBar=tk.Tk()
    qProgressBar.title("Sholl Analysis")

    # Create a progressbar widget
    progress_bar1 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    progress_bar2 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    progress_bar3 = ttk.Progressbar(qProgressBar, orient="horizontal",
                                  mode="determinate", maximum=100, value=0)
    # And a label for it
    label_1 = tk.Label(qProgressBar, text="Dendrite ReOrder")
    label_2 = tk.Label(qProgressBar, text="Filament Progress")
    label_3 = tk.Label(qProgressBar, text="Working....")

    # Use the grid manager
    label_1.grid(row=0, column=0,pady=10)
    label_2.grid(row=1, column=0,pady=10)
    label_3.grid(row=2, column=0,pady=10)

    progress_bar1.grid(row=0, column=1)
    progress_bar2.grid(row=1, column=1)
    progress_bar3.grid(row=2, column=1)

    ##################################################################
    # Set Input Window to center of screen
    # Gets the requested values of the height and widht.
    windowWidth = qProgressBar.winfo_reqwidth()
    windowHeight = qProgressBar.winfo_reqheight()
    # Gets both half the screen width/height and window width/height
    positionRight = int(qProgressBar.winfo_screenwidth()/2 - windowWidth/2)
    positionDown = int(qProgressBar.winfo_screenheight()/2 - windowHeight/2)
    # Positions the window in the center of the page.
    qProgressBar.geometry("+{}+{}".format(positionRight, positionDown))
    ##################################################################
    qProgressBar.geometry('250x130')
    qProgressBar.attributes("-topmost", True)

    # Necessary, as the qProgressBar object needs to draw the progressbar widget
    # Otherwise, it will not be visible on the screen
    qProgressBar.update_idletasks()
    progress_bar1['value'] = 0
    qProgressBar.update_idletasks()

    start = time.time()

    ##################################################################
    ##################################################################
    #Get Image properties
    vDataMin = (vImage.GetExtendMinX(),vImage.GetExtendMinY(),vImage.GetExtendMinZ())
    vDataMax = (vImage.GetExtendMaxX(),vImage.GetExtendMaxY(),vImage.GetExtendMaxZ())
    vDataSize = (vImage.GetSizeX(),vImage.GetSizeY(),vImage.GetSizeZ())
    vSizeT = vImage.GetSizeT()
    vSizeC = vImage.GetSizeC()
    vType = vImage.GetType()

    aXvoxelSpacing= (vDataMax[0]-vDataMin[0])/vDataSize[0]
    aYvoxelSpacing= (vDataMax[1]-vDataMin[1])/vDataSize[1]
    aZvoxelSpacing = round((vDataMax[2]-vDataMin[2])/vDataSize[2],3)
    vSmoothingFactor=aXvoxelSpacing*2

    #Get the Current Filament Object
    vNumberOfFilaments=vFilaments.GetNumberOfFilaments()
    vFilamentIds= vFilaments.GetIds()
    vFilamentIdsSelected = vFilaments.GetSelectedIds()


    ################################################
    ################################################
    #Create a new folder object for new Sholl Spot intersections
    # vGroupFolder_ShollSpots = vImarisApplication().GetFactory()
    vShollResult = vImarisApplication.GetFactory().CreateDataContainer()
    vShollResult.SetName('Sholl Intersections per sphere - '+ str(vFilaments.GetName()))

    vShollDendrites = vImarisApplication.GetFactory().CreateDataContainer()
    vShollDendrites.SetName('Sholl Dendrites - '+ str(vFilaments.GetName()))

    vShollResult2 = vImarisApplication.GetFactory().CreateDataContainer()
    vShollResult2.SetName(' Advanced Sholl Analysis - '+ str(vFilaments.GetName()))

    vSpotFilamentPoints = vImarisApplication.GetFactory().CreateDataContainer()
    vSpotFilamentPoints.SetName(' Dendrite Analysis - '+ str(vFilaments.GetName()))

    vSurfaceConvexHull = vImarisApplication.GetFactory().CreateDataContainer()
    vSurfaceConvexHull.SetName(' Dendritic Field Analysis - '+ str(vFilaments.GetName()))

    vSurfaceHull = vFactory.CreateSurfaces()


    ################################################
    ################################################
    vSegmentBranchLength=[]
    wSegmentIdsSpine=[]
    wSegmentIdsDendrite=[]
    wSegmentIdsALL=[]

    vSpotPositionAllShollSpheresALL= []
    vSpotPositionAllShollSpheresPerFilamentALL = []
    vNumberofShollIntersectionsALL = []
    vNewStatSpotShollDistanceALL = []
    vNewStatTortuosityPerSegment = []

    vSpotPositionAllShollSpheres=[]
    vFilamentCountActual=0
    vSpotPositionAllShollSpheresPerFilament=[]
    vNumberofShollIntersections=[]
    vNewStatSpotShollDistance=[]
    vNewStatNumberShollIntersectionPerFilament=[]
    vNewStatSpotNumberShollIntersections=[]
    vNumberofIntersectionsPerShollSphere=[]
    wCompleteShollSpotDistAlongFilamentStat=[]
    vNumberOfShollIntersectionPerSpherePerFilament=[]
    wCompleteDendriteTimeIndex=[]
    wCompleteFilamentTimeIndex=[]
    vNewStatCompleteFilamentBranchPointDistToSomaMean = []
    vNewStatCompleteFilamentTerminalPointDistToSomaMean = []
    vNewStatCompleteFilamentTerminalPointDistToSomaMax = []
    vNewStatCompleteTortuosityPerSegment = []
    vNewStatCompleteTortuosityPerSegmentSum = []
    vNewStatTortuosityPerFilament = []
    zAllFilamentsRegularityIndexBP = []
    zAllFilamentsRegularityIndexTP = []
    vNodeTypesComplete = []
    wFilamentBranchPointsComplete = []
    wFilamentTerminalPointsComplete = []
    vNodeFilamentIdsComplete = []
    wCompeteSegmentBranchDepthPerFilament = []
    wNewStatConvexHullVolumePerFilament = []
    wNewStatConvexHullAreaPerFilament = []
    wCompleteTerminalPointsDistAlongFilamentStatALL = []
    wCompleteBranchPointsDistAlongFilamentStatALL = []

    wLabelListTerminalPoints = []
    wLabelListBranchPoints = []


    ###############################################################################
    ###############################################################################

    zEmptyfilaments=[]
    for aFilamentIndex in range(vNumberOfFilaments):
        vFilamentsRadius = vFilaments.GetRadii(aFilamentIndex)
        if len(vFilamentsRadius)==1:
            zEmptyfilaments.append(int(aFilamentIndex))
    vFilamentIds=[v for i,v in enumerate(vFilamentIds) if i not in zEmptyfilaments]


    ###############################################################################
    ###############################################################################
    #Loop each Filament
    for aFilamentIndex in range(vNumberOfFilaments):

        vFilamentsIndexT = vFilaments.GetTimeIndex(aFilamentIndex)
        vFilamentsXYZ = vFilaments.GetPositionsXYZ(aFilamentIndex)
        vFilamentsRadius = vFilaments.GetRadii(aFilamentIndex)
        vFilamentTimepoint = vImage.GetTimePoint(vFilamentsIndexT)


    #Test if the time point has empty filament matrix or filament start
    #point and nothing more
        if len(vFilamentsRadius)==1:
            continue
        vFilamentCountActual=vFilamentCountActual+1
        vFilamentsEdgesSegmentId = vFilaments.GetEdgesSegmentId(aFilamentIndex)
    #Find unique values of variable using set, the copnvert back to list
        vSegmentIds=list(set(vFilamentsEdgesSegmentId))
        vNumberOfDendriteBranches = len(vSegmentIds)#total number dendrite segments
        vNumberOfFilamentPoints= len(vFilamentsRadius)#including starting point
        vFilamentTimeIndex=[vFilamentsIndexT]*len(vFilamentsRadius)#for filament spot creation
        vFilamentsEdges = vFilaments.GetEdges(aFilamentIndex)
        vTypes = vFilaments.GetTypes(aFilamentIndex)
        vBeginningVertex = vFilaments.GetBeginningVertexIndex(aFilamentIndex)
        #Test whether filament has a starting point
        if vBeginningVertex==[]:
            continue
        else:
            vBeginningVertexPositionXYZ=vFilamentsXYZ[vBeginningVertex]
        SegmentCountALL=0
        vBranchIndex=0

        vAllFilamentDendriteLengthSET = vFilaments.GetStatisticsByName('Segment Length')
        vAllFilamentDendriteLengthIds = vAllFilamentDendriteLengthSET.mIds
        vAllFilamentDendriteLength = vAllFilamentDendriteLengthSET.mValues
        vAllFilamentDendriteBranchDepthSET = vFilaments.GetStatisticsByName('Segment Branch Depth')
        vAllFilamentDendriteBranchDepthIds = vAllFilamentDendriteBranchDepthSET.mIds
        vAllFilamentDendriteBranchDepth = vAllFilamentDendriteBranchDepthSET.mValues

        if not vAllFilamentDendriteLengthIds:
            vAllFilamentDendriteLengthSET = vFilaments.GetStatisticsByName('Dendrite Length')
            vAllFilamentDendriteLengthIds = vAllFilamentDendriteLengthSET.mIds
            vAllFilamentDendriteLength = vAllFilamentDendriteLengthSET.mValues
            vAllFilamentDendriteBranchDepthSET = vFilaments.GetStatisticsByName('Dendrite Branch Depth')
            vAllFilamentDendriteBranchDepthIds = vAllFilamentDendriteBranchDepthSET.mIds
            vAllFilamentDendriteBranchDepth = vAllFilamentDendriteBranchDepthSET.mValues


    ####Remove spines for branch/terminal point identification
        # np.where(np.array(vTypes) == 1)[0].tolist()
        # np.where(np.array(vFilamentsEdges) == x)
        # np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0]

        # # vFilamentsEdgesDendritesOnly = np.delete(np.array(vFilamentsEdges),np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0],axis=0)
        # vFilamentsEdgesDendritesOnly=[l.tolist() for l in np.delete(np.array(vFilamentsEdges),np.where(np.isin(vFilamentsEdges,np.where(np.array(vTypes) == 1)[0].tolist()))[0],axis=0)]


        #create new FilamentXYZ for dendrite spilting
        zNewFilamentsXYZ = vFilamentsXYZ[:]
        zNewFilamentsRadius = vFilamentsRadius[:]
        zNewFilamentsEdges = np.array(vFilamentsEdges[:])
        zNewFilamentsTypes = vTypes[:]

    ###############################################################################
    ###############################################################################
    ###############################################################################
    #Easier way to identify branch point and terminal points per filament object

        vStatPtPositionXSet = vFilaments.GetStatisticsByName('Pt Position X')
        vStatPtPositionYSet = vFilaments.GetStatisticsByName('Pt Position Y')
        vStatPtPositionZSet = vFilaments.GetStatisticsByName('Pt Position Z')
        vStatPtPosition = []
        vStatPtPosition.append(vStatPtPositionXSet.mValues)
        vStatPtPosition.append(vStatPtPositionYSet.mValues)
        vStatPtPosition.append(vStatPtPositionZSet.mValues)

        vStatPtPositionFactors = vStatPtPositionXSet.mFactors
        vStatPtPositionIds =  vStatPtPositionXSet.mIds

        wFilamentTerminalPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Terminal')[0].tolist()]
        wFilamentBranchPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Branch')[0].tolist()]
        wFilamentStartingPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Segment Beginning')[0].tolist()]

        if not wFilamentTerminalPointsNEW.any():# == []:
            wFilamentTerminalPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Terminal')[0].tolist()]
            wFilamentBranchPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Branch')[0].tolist()]
            wFilamentStartingPointsNEW = np.array(vStatPtPosition).T[np.where(np.array(vStatPtPositionFactors)[4]=='Dendrite Beginning')[0].tolist()]

        #Find in Branch, Terminal and starting point - in current filament
        wFilamentBranchPointsNEWCurrent = np.array(wFilamentBranchPointsNEW)[np.where(np.isin(wFilamentBranchPointsNEW[:,0],np.array(vFilamentsXYZ)[:,0]))[0].tolist()]
        wFilamentTerminalPointsNEWCurrent = np.array(wFilamentTerminalPointsNEW)[np.where(np.isin(wFilamentTerminalPointsNEW[:,0],np.array(vFilamentsXYZ)[:,0]))[0].tolist()]
        wFilamentStartingPointsNEWCurrent = np.array(wFilamentStartingPointsNEW)[np.where(np.isin(wFilamentStartingPointsNEW[:,0],np.array(vFilamentsXYZ)[:,0]))[0].tolist()]

        wFilamentBranchPointsComplete.extend(wFilamentBranchPointsNEWCurrent.tolist())
        wFilamentTerminalPointsComplete.extend(wFilamentTerminalPointsNEWCurrent.tolist())


    ###############################################################################
    #Branch Point Classification
        # #identify position index that match branch point
        # np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[i][0])[0].tolist()[0]
        # #identify all filament edges that use that index
        # np.where(np.array(vFilamentsEdges) == np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[0][0])[0].tolist()[0])[0].tolist()

    #Terminal Point segmentID Classification
        # #identify position index that match XYZ branch point position
        # np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist()
        # #identify all index of filament edge that use that Point index
        # np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())

        # wTerminalSegmentID = np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())[0].tolist()[0]
        # vFilamentsEdgesSegmentId[wTerminalSegmentID]

        #Find Terminal segmentIds
        wTerminalSegmentIDs=[]
        for i in range(len(wFilamentTerminalPointsNEWCurrent)):
            wTerminalSegmentIDcurrent = np.where(np.array(vFilamentsEdges) == np.where((np.array(vFilamentsXYZ)==wFilamentTerminalPointsNEWCurrent[i].tolist()).all(1))[0].tolist())[0].tolist()[0]
            wTerminalSegmentIDs.append(vFilamentsEdgesSegmentId[wTerminalSegmentIDcurrent])

    ###############
        wNodeSegments = []
        vNodeTypePerFilament = []
        for i in range(len(wFilamentBranchPointsNEWCurrent)):

        #Identify segment IDs that are attached to branch point
            wNodeSegments.append(np.array(vFilamentsEdgesSegmentId)[np.where(np.array(vFilamentsEdges) == np.where(np.array(vFilamentsXYZ)[:,0] == wFilamentBranchPointsNEWCurrent[i][0])[0].tolist()[0])[0].tolist()].tolist())
            #Identify if segments attached to node are a terminal segment
            #count number per each node
            # len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i]))
            vNodeTypePerFilament.append(len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i])))
            vNodeTypesComplete.append(len(np.intersect1d(wTerminalSegmentIDs,wNodeSegments[i])))
        #list filamientID for each node
        vNodeFilamentIdsComplete.extend([vFilamentIds[vFilamentCountActual-1]]*len(wFilamentBranchPointsNEWCurrent))

            #categories.  1) Arborization, 2)Continuation, 3) Terminal
            #1)Arborization (A) nodes have two bifurcating children.
            #2)Continuation (C) nodes have one bifurcating and one terminating child.
            #3)Termination (T) nodes have two terminating children.
            #4)Other (T+) nodes more than 2 terminating children.

    ###############################################################################
    ###############################################################################
        vAllSegmentsPerFilamentRadiusWorkingInserts = []
        vAllSegmentsPerFilamentPositionsWorkingInserts = []
        vAllSegmentsAnglesPerFilament = []
        vAllSegmentsTypesPerFilamentWorkingInserts=[]
        vAllSegmentIdsPerFilamentInserts = []
        vNewStatAnglesPerCurrentFilamentSpot = []
        vNewStatAnglesPerCurrentFilamentSpotMean = []
        vNewStatTortuosityPerSegmentSum = []
        zReorderedvSegmentIds =[]
        zReorderedvSegmentType = []
        wDistanceValuesMax = []
        wDistanceValuesMin = []
    ###############################################################################
        #Loop through dendrite segments, terminal segements and spine segments
        vSegmentBranchDepthCurrent = []
        for vBranchIndex in range (vNumberOfDendriteBranches):
            SegmentCountALL=SegmentCountALL+1
            zReOrderedFilamentPointIndexWorking = []
            zReOrderedFilamentPositionsWorking = []
            zReOrderedFilamentRadiusWorking = []
    ###############################################################################
            if not vSegmentIds[vBranchIndex] in vAllFilamentDendriteLengthIds:
                continue
    ###############################################################################
    #Set the ID for dendrite segment
            vSegmentIdWorking = vSegmentIds[vBranchIndex]
            #Isolate all edges for the working segment
            vSegmentWorkingPointIndex=[i for i in range(len(vFilamentsEdgesSegmentId))
                                       if vFilamentsEdgesSegmentId[i] == vSegmentIdWorking]
            if len(vSegmentWorkingPointIndex)>1:
                vSegmentEdgesWorking=list(itemgetter(*vSegmentWorkingPointIndex)(vFilamentsEdges))
            else:
                vSegmentEdgesWorking=[x[1] for x in enumerate(vFilamentsEdges)
                              if x[0] in vSegmentWorkingPointIndex]

            #Match segmentID with Branch Depth Value
            # np.where(np.array(vAllFilamentDendriteBranchDepthIds) == vSegmentIdWorking)[0].tolist()[0]
            vSegmentBranchDepthCurrent.append(vAllFilamentDendriteBranchDepth[np.where(np.array(vAllFilamentDendriteBranchDepthIds) == vSegmentIdWorking)[0].tolist()[0]])

            #Find unique edge indices using "set" and convert back to list
            vEdgesUniqueWorking=list(set(x for l in vSegmentEdgesWorking for x in l))

       #Find current Working Dendrite segment parts
            vSegmentPositionsWorking=list(itemgetter(*vEdgesUniqueWorking)(vFilamentsXYZ))
            vSegmentRadiusWorking=list(itemgetter(*vEdgesUniqueWorking)(vFilamentsRadius))
            vSegmentTypesWorking=list(itemgetter(*vEdgesUniqueWorking)(vTypes))

            #Unit length number of points that make it up
            vSegmentBranchLength.append(len(vEdgesUniqueWorking))

            #Collate all SegmentId by Type (dendrtie or spine)
            if max(vSegmentTypesWorking)==0:
                wSegmentIdsDendrite.append(vSegmentIdWorking)
                wSegmentIdsALL.append(vSegmentIdWorking)
            else:
                wSegmentIdsSpine.append(vSegmentIdWorking)
                wSegmentIdsALL.append(vSegmentIdWorking)
                continue
    ##################################################################
    #Test is the segmentlength is too short to reoreeder or fil spots. Currently set to 5
    #         if len(vSegmentPositionsWorking)<3:
    #         #Collate with all data but bypass reorder and Fill steps.
    #             vAllSegmentsPerFilamentRadiusWorkingInserts.extend([vSegmentRadiusWorking])
    #             vAllSegmentsPerFilamentPositionsWorkingInserts.extend([vSegmentPositionsWorking])
    # ##############################################################################
    #         #Measure distance of all FilamentPoint position to Filament Startingn point
    #         #To find out which Denrite segment intersects with each sphere, to
    #         #hopefully reduce the time of process irrelevant segments
    #             wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
    #             wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))

    #             vNewStatTortuosityPerSegment.append(0)

    #             continue
    ###############################################################################
    ###############################################################################
    #find gaps in the dendrite length and fill with extra spots
    #For bouton detect and Spots display
            if max(vSegmentTypesWorking)==0:# and vOptionFilamentToSpotsFill==1 or vOptionFilamentBoutonDetection==1 or vOptionFilamentCloseToSpots==1 or vOptionDendriteToDendriteContact==1 or vOptionFilamentToFilamentContact==1:
    #ReOrder segment
            #Reordering
            #flattten list
                zNum=reduce(operator.concat, vSegmentEdgesWorking)
                #find duplicates
                zDup=[zNum[i] for i in range(len(zNum)) if not i == zNum.index(zNum[i])]
                #find individuals - start and end index
                zIndiv=list(set(zNum).difference(zDup))

                zStartIndex=zIndiv[0]
                zEndIndex=zIndiv[1]
                zReOrderedFilamentPointIndexWorking.append(zStartIndex)
                zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zStartIndex])
                zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zStartIndex])

            #start of loop for each dendrite segment
                for k in range (len(vSegmentRadiusWorking)-1):
                    if k==0:
                        #find nested list index that contains StartIndex (5,1)--next point is (5,0)
                        #convert tuple to list
                        zEdgesNext=list(reduce(operator.concat, [(index_,sub_list.index(zStartIndex))\
                             for index_, sub_list in enumerate(vSegmentEdgesWorking)\
                             if zStartIndex in sub_list]))

                        #find next segment index delete previous one
                        if zEdgesNext[1]==1:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][0]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        else:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][1]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        #collate segment indices
                        zReOrderedFilamentPointIndexWorking.append(zNextSegmentIndex)
                        zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zNextSegmentIndex])
                        zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zNextSegmentIndex])

                    else:
                       #find nested list index that contains NextIndex
                       #convert tuple to list
                        zEdgesNext=list(reduce(operator.concat, [(index_,sub_list.index(zNextSegmentIndex))\
                             for index_, sub_list in enumerate(vSegmentEdgesWorking)\
                             if zNextSegmentIndex in sub_list]))

                        if zEdgesNext[1]==1:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][0]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list
                        else:
                            zNextSegmentIndex=vSegmentEdgesWorking[zEdgesNext[0]][1]#next index in sequence
                            vSegmentEdgesWorking.pop(zEdgesNext[0])#remove list of list

                        zReOrderedFilamentPointIndexWorking.append(zNextSegmentIndex)
                        zReOrderedFilamentPositionsWorking.append(vFilamentsXYZ[zNextSegmentIndex])
                        zReOrderedFilamentRadiusWorking.append(vFilamentsRadius[zNextSegmentIndex])
                    zReorderedvSegmentIds.extend([vSegmentIdWorking]*len(vSegmentRadiusWorking))
                    zReorderedvSegmentType.extend([max(vSegmentTypesWorking)]*len(vSegmentRadiusWorking))

        ##############################################################################
        ##############################################################################
        #fill spots in filament point gaps
                vSegmentRadiusWorkingInserts=zReOrderedFilamentRadiusWorking[:]
                vSegmentPositionsWorkingInserts=zReOrderedFilamentPositionsWorking[:]
                if max(vSegmentTypesWorking)==0:
                    for loop in range (3):#loop through 3 times
                        i=0
                        while i<=(len(vSegmentPositionsWorkingInserts)-2):
                            vFillFilamentPairDist=pdist([vSegmentPositionsWorkingInserts[i],vSegmentPositionsWorkingInserts[i+1]])
                            vFillFilamentRadialSum=vSegmentRadiusWorkingInserts[i]+vSegmentRadiusWorkingInserts[i+1]
                            if vFillFilamentPairDist>vFillFilamentRadialSum:
            #insert Radius at next spot
                                vSegmentRadiusWorkingInserts[i+1:i+1]=[vFillFilamentRadialSum/2]
                                vSegmentPositionsWorkingInserts[i+1:i+1]=[np.divide(np.add(vSegmentPositionsWorkingInserts[i+1],
                                                                                            vSegmentPositionsWorkingInserts[i]),2).tolist()]
                            i=i+1
                vAllSegmentsPerFilamentRadiusWorkingInserts.extend([vSegmentRadiusWorkingInserts])
                vAllSegmentsPerFilamentPositionsWorkingInserts.extend([vSegmentPositionsWorkingInserts])
                # vAllSegmentsTypesPerFilamentWorkingInserts.extend([max(vSegmentTypesWorking)]*len(vSegmentRadiusWorkingInserts))
                # vAllSegmentIdsPerFilamentInserts.extend([vSegmentIdWorking]*len(vSegmentRadiusWorkingInserts))
    ##############################################################################
    ############Calculating dendrite angles, by spiltting each segment into small bits
                ##Calcualte the angle between each adjacent points along the segment
                vSegmentAngles =[]
                vAnglesPerCurrentSegment =[]
                vAnglesPerCurrentSegmentMean = []
                if len(vSegmentPositionsWorkingInserts) > 2:
                    for i in range(len(vSegmentPositionsWorkingInserts)-2):
                        # Determine the plane position of the 3 reference points
                        p1 = np.array(vSegmentPositionsWorkingInserts[i]) # Position of first point on plane
                        p2 = np.array(vSegmentPositionsWorkingInserts[i+1]) # Position of second point on plane
                        p3 = np.array(vSegmentPositionsWorkingInserts[i+2]) # Position of third point on plane
                        # These two vectors are in the plane
                        v1 = p3 - p1
                        v2 = p2 - p1
                        #dot product
                        p = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
                        #compute norms
                        n1 = math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2])
                        n2 = math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2])
                        #Compute angle
                        try:
                            ang = math.acos(p / (n1 * n2))
                        except:
                            ang = math.acos(1)

                        # Convert to degrees if you want
                        vSegmentAngles.append(math.degrees(ang))
                else:
                    vSegmentAngles.append(0)
                vAnglesPerCurrentSegment.append(vSegmentAngles)

                #Calcualte the average of every second
                #Every spot in current segment with mean angle
                if len(vAnglesPerCurrentSegment[0]) == 2:
                    vAnglesPerCurrentSegmentMean.append(mean(vAnglesPerCurrentSegment[0]))
                elif len(vAnglesPerCurrentSegment[0]) == 1:
                        vAnglesPerCurrentSegmentMean.append(vAnglesPerCurrentSegment[0])
                else:
                    for i in range (len(vAnglesPerCurrentSegment[0])):
                        vAnglesPerCurrentSegmentMean.append(mean(vAnglesPerCurrentSegment[0][i:i+2]))
                    vAnglesPerCurrentSegmentMean[-1] = mean(vAnglesPerCurrentSegmentMean[-2:])
                    vAnglesPerCurrentSegmentMean[-2] = mean(vAnglesPerCurrentSegmentMean[-3:])

                # #compile all spot angle values for each point into single variable
                # vCompleteSegmentsAnglesPerFilamentSpot.extend(vAnglesPerCurrentSegment)
                # vCompleteSegmentsAnglesPerFilamentSpotMean.extend(vAnglesPerCurrentSegmentMean)

                #compile all angles for each point current filament
                vNewStatAnglesPerCurrentFilamentSpot.extend(vAnglesPerCurrentSegment)
                vNewStatAnglesPerCurrentFilamentSpotMean.extend(vAnglesPerCurrentSegmentMean)

                # if vBranchIndex == 30:
                #     x=1
                # if vBranchIndex == 31:
                #     x=1
                # if vBranchIndex == 49:
                #     x=1
                #Calculate Tortuosity
                if vSegmentAngles[0] == 0:
                    vNewStatTortuosityPerSegment.append(float(0))
                elif len(vSegmentAngles)==1 and vSegmentAngles[0]>0:
                    vNewStatTortuosityPerSegment.append(float(sum(abs(np.array(vAnglesPerCurrentSegmentMean[0])))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi))
                else:
                    vNewStatTortuosityPerSegment.append(float(sum(abs(np.array(vAnglesPerCurrentSegmentMean)))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi))

                vNewStatCompleteTortuosityPerSegmentSum.append(sum(abs(np.array(vAnglesPerCurrentSegmentMean))))
                vNewStatCompleteTortuosityPerSegment.append(sum(abs(np.array(vAnglesPerCurrentSegmentMean)))/(len(vSegmentPositionsWorkingInserts)-2)*math.pi)

    ##############################################################################
            #Measure distance of all FilamentPoint position to Filament Startingn point
            #To find out which Denrite segment intersects with each sphere, to
            #hopefully reduce the time of process irrelevant segments
            # if len(zIndiv)<2:
            #     wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
            #     wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorking)))
            # else:
            wDistanceValuesMax.append(np.amax(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorkingInserts)))
            wDistanceValuesMin.append(np.amin(cdist([vBeginningVertexPositionXYZ], vSegmentPositionsWorkingInserts)))
    ##############################################################################
    ##############################################################################
    # Insert dual progress bar one dendrite branches
    # one for filaments
        #Progress bar for dendrite segments
            progress_bar1['value'] = int((vBranchIndex+1)/vNumberOfDendriteBranches*100) #  % out of 100
            qProgressBar.update()
            elapsed = time.time() - start
            #print('ReOrdered')
    ##############################################################################
    ##############################################################################

    #Create a normalize color basd on the number of potential Sholl spheres
            wApproxNumSpheres=(max(wDistanceValuesMax)/vShollRadius).astype(int)
            wColorList=np.linspace(start=.1,stop=.9,num=wApproxNumSpheres)

            zShollLabelsFinal=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+1), vShollRadius))


    ##############################################################################
        vShollSpotCount=0
        vShollNodeCount=0
    ################################################
        wCompleteShollSpotDistAlongFilamentStatWorking=[]
        wCompleteTerminalPointsDistAlongFilamentStatWorking=[]
        wCompleteBranchPointsDistAlongFilamentStatWorking=[]

        vDendriteALLXSphere=[]
        qSpotinQuestionALL=[]
    ################################################
    ################################################
        aIntensityLowerThresholdManual=5
        aShollIndex=0
        vBranchIndex=0
        zShollLabelsAll=[]
        vShollFinalIndex=0

        # start2 = time.time()

    #Progress through each Sholl Sphere
        for aShollIndex in range (round(max(wDistanceValuesMax))):
            vSpotPositionCurrentShollSphere=[]#Clears current Sholl spots
            count=0
            #Set lower and upper threshold for the Sholl Mask
            aIntensityLowerThresholdManual=aIntensityLowerThresholdManual+1
            aIntensityUpperThresholdManual=aIntensityLowerThresholdManual+(aXvoxelSpacing*2)
            qSpotinQuestion=[]
            qNodeinQuestion=[]
            qShollSpotNodeClassify=[]

    #Create list of Sholl labels
            zShollLabelsAll.append(str(aIntensityLowerThresholdManual))

        # Process a each branch and find point distance to starting point
        # filter by current sholl sphere distance
        # Test if Dendrite fails on the Sholl sphere
        #find the indices of segments that cross the current Sholl Sphere
            vSegmentsCurrentShollSphereIndexMax=[index for index,value in enumerate(wDistanceValuesMax)
                                              if value >= aIntensityLowerThresholdManual]
            vSegmentsCurrentShollSphereIndexMin=[index for index,value in enumerate(wDistanceValuesMin)
                                              if value <= aIntensityLowerThresholdManual]
            wSegmentIndexIntersectSholl=list(set(vSegmentsCurrentShollSphereIndexMax).intersection(vSegmentsCurrentShollSphereIndexMin))

            if wSegmentIndexIntersectSholl==[]:
                break
    ##############################################################################
            # start = time.time()

            for vBranchIndex in range (len(wSegmentIndexIntersectSholl)):
                vDendritePositionsNEW=vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]]
                #Measure distance from each point to starting for current segment
                vDistanceListValues=cdist([vBeginningVertexPositionXYZ],
                                          vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]])
                #Set base for each filament point to false
                vDendriteXSphere = np.array([0]*(np.size(vDistanceListValues)))
                #Test filament points to find those near current sholl sphere
                wShollIntersectionIndex=np.where(np.logical_and(vDistanceListValues>float(aIntensityLowerThresholdManual), vDistanceListValues<aIntensityUpperThresholdManual))
                wShollIntersectionIndex = wShollIntersectionIndex[1].tolist()

            #if no filament point is detected, within these defined limits
                #find the closest point and use that as the lone Sholl intersection
                if len(wShollIntersectionIndex)==0:#if list array is empty
                    wShollIntersectionIndex = np.where(abs(vDistanceListValues-aIntensityLowerThresholdManual) == np.amin(abs(vDistanceListValues-aIntensityLowerThresholdManual)))[1].tolist()
                #convert to real numbers
                vDendriteXSphere[np.array(wShollIntersectionIndex)]=int(1)
                #convert to positionsXYZ
                # vDendriteXSpherePositionXYZ=itemgetter(*wShollIntersectionIndex[1].tolist())(vAllSegmentsPerFilamentPositionsWorkingInserts[wSegmentIndexIntersectSholl[vBranchIndex]])
                if len(vDendriteXSphere)>0:
                    #Need to add one zero to the end of series so that a peak can be identified at the tail end
                    vDendriteXSphere=np.pad(vDendriteXSphere, (0,2), 'constant')
                    PeakIndex, _ = find_peaks(vDendriteXSphere, height=0.25)
                    # remove the trailing zero
                    PeakIndexWorking=PeakIndex.tolist()
                    #Test for single gaps in the dendrite peak and fill them. Likely not
                    #enough to warrrent a true Sholl intersection cross
                    if len(PeakIndexWorking)>1:
                        for i in range(len(PeakIndexWorking)-1):
                            if PeakIndexWorking[i]+1==PeakIndexWorking[i+1]-1:
                                vDendriteXSphere[PeakIndexWorking[i]+1]=1

                    #reset binary segment to original removing doube pad
                    vDendriteXSphere = vDendriteXSphere[:-1]
                    vDendriteXSphere = vDendriteXSphere[:-1]
    #qSpotinQuestion Scenarios
    #1---single point at begining of segment
    #2---multiple points at beginning of segment
    #3---all points including fist and last
    #4---single point at the end
    #5---multiple points at the end
    #0---no issues

    #########################
        #Scenario#1----Test if first point is a sholl intersection -add to peak index list
                    if vDendriteXSphere[0]==1:
                        PeakIndexWorking=np.insert(PeakIndexWorking, 0, 0).astype(int)
    ##################################################
                    #compile each segments peaks
                    vDendriteALLXSphere.append(vDendriteXSphere)

                #Analysis of each Peak index and surrounding peaks
                    for i in range(len(PeakIndexWorking)):
                        count=0
                        b=vDendriteXSphere[PeakIndexWorking[i]:]#generated series starting from next peakpoint
                        b=np.append(b,0)
                        while b[count]==1:
                            count=count+1
                    #Is peak at front end of semgent (2 in length)
                        if PeakIndexWorking[i]==0:
                            # vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            qSpotinQuestion=True
                            if count==1:
                                qShollSpotNodeClassify.append(1)
                            else:
                                qShollSpotNodeClassify.append(2)
                            qNodeinQuestion.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            vShollNodeCount=vShollNodeCount+1
                            vShollSpotCount=vShollSpotCount+1

                    #Is peak at tail end of semgent (2 in length)- branch or terminal
                        elif PeakIndexWorking[i]!=0 and vDendriteXSphere[-1]==1:
                            vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[-1])# grab last point in segment
                        #Test if this Sholl Intersection is a Terminal point
                            qIsSpotaTerminalPoint =  any(item in wFilamentTerminalPointsNEWCurrent for item in vSpotPositionCurrentShollSphere[-1])
                            if qIsSpotaTerminalPoint == True:
                                vShollSpotCount=vShollSpotCount+1
                            else:
                                del vSpotPositionCurrentShollSphere[-1]#Remove added Sholl spot position
                                qSpotinQuestion=True
                                if count==1:
                                    qShollSpotNodeClassify.append(3)
                                else:
                                    qShollSpotNodeClassify.append(4)
                                qNodeinQuestion.append(vDendritePositionsNEW[-1])
                                vShollNodeCount=vShollNodeCount+1
                                vShollSpotCount=vShollSpotCount+1
                        else:
                            vSpotPositionCurrentShollSphere.append(vDendritePositionsNEW[PeakIndexWorking[i]])
                            vShollSpotCount=vShollSpotCount+1
            elapsed = time.time() - start
            #print('ProcessBranches')
    ###############################################################################
    ###############################################################################

    ###############################################
    ###############################################
    #Correct the edge related intersections - after last branch index
    #Process and remove duplicate spots and reduce spots near node.
            if qSpotinQuestion==True:#Test if there are any questionable intersections
                #Find Unique Spots, counts and indices in question
                qUniqueNodes, qUniqueIndex,qUniqueCounts = np.unique(np.array(qNodeinQuestion), return_counts=True, return_index=True, axis=0)
                for qIndex in range (len(qUniqueIndex)):
                    #Find index of unique nodes in question
                    qNodeinQuestionIndexWorking=np.where((qNodeinQuestion == qUniqueNodes[qIndex]).all(axis=1))[0].tolist()
                    if qUniqueCounts[qIndex]==1:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-1
                    if qUniqueCounts[qIndex]==2:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-1
                    if qUniqueCounts[qIndex]==3:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-2
                    if qUniqueCounts[qIndex]==4:
                        vSpotPositionCurrentShollSphere.append(qUniqueNodes[qIndex].tolist())
                        vShollSpotCount=vShollSpotCount-3

    ###############################################################################
            #Compile all Sholl Intersections per Sholl sphere (uneditted)
            vSpotPositionAllShollSpheresALL.extend([vSpotPositionCurrentShollSphere])
            vSpotPositionAllShollSpheresPerFilamentALL.extend([vSpotPositionCurrentShollSphere])
            #Number of sholl intersections per filament
            vNumberofShollIntersectionsALL.append(len(vSpotPositionCurrentShollSphere))
            vNewStatSpotShollDistanceALL.extend([aIntensityLowerThresholdManual]*len(vSpotPositionAllShollSpheresPerFilamentALL[aShollIndex]))

            if aIntensityLowerThresholdManual in zShollLabelsFinal:
                #Compile all Sholl Intersections per Sholl sphere (uneditted)
                vSpotPositionAllShollSpheres.extend([vSpotPositionCurrentShollSphere])
                vSpotPositionAllShollSpheresPerFilament.extend([vSpotPositionCurrentShollSphere])
                #Number of sholl intersections per filament
                vNumberofShollIntersections.append(len(vSpotPositionCurrentShollSphere))
                vNewStatSpotShollDistance.extend([aIntensityLowerThresholdManual]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]))

    ###############################################################################
        #Create Sholl Spots for the current Sholl Sphere for current Filament
                vShollCurrentSpotRadius=[1]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex])
                vShollCurrentSpotTime=[vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex])

                if len(vShollCurrentSpotRadius) > 0 and qSplitShollspheres == 1:
                    #Create the a new Spots generated from teh center of Mass
                    vNewSpots = vImarisApplication.GetFactory().CreateSpots()
                    vNewSpots.Set(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex],
                                  [vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]),
                                  [1]*len(vSpotPositionAllShollSpheresPerFilament[vShollFinalIndex]))
                    vNewSpots.SetName('FilamentID:'+str(vFilamentIds[vFilamentCountActual-1]) +
                        ' -- ' + str(aIntensityLowerThresholdManual) +
                                      ' um Sholl Sphere')
                    zRandomColor=((wColorList[vShollFinalIndex]) * 256 * 256 * 256 )
                    vNewSpots.SetColorRGBA(zRandomColor)#Set Random color
                    #Add new spots to Surpass Scene
                    vShollResult.AddChild(vNewSpots, -1)
                    vImarisApplication.GetSurpassScene().AddChild(vShollResult, -1)

            #Number of sholl intersections per sholl sphere
                vNumberofIntersectionsPerShollSphere.append(len(vSpotPositionCurrentShollSphere))
                vNewStatSpotNumberShollIntersections.extend([vNumberofIntersectionsPerShollSphere[vShollFinalIndex]]*vNumberofIntersectionsPerShollSphere[vShollFinalIndex])


        #Reset stat for next Sholl Sphere
                vSpotPositionCurrentShollSphere=[]
                vShollSpotTime=[]
                vShollSpotRadius=[]
                vShollSpotCount=0
                vDendriteALLXSphere=[]
                vShollFinalIndex=vShollFinalIndex+1

        # elapsed = time.time() - start2
        #print('ProcessedALLSholl')
        #after the last sholl sphere
        vNewStatNumberShollIntersectionPerFilament.append(sum(vNumberofShollIntersections))
        vNumberOfShollIntersectionPerSpherePerFilament.extend(vNumberofIntersectionsPerShollSphere)
        vNumberofShollIntersections=[]
        vNumberofIntersectionsPerShollSphere=[]

        vNewFilamentStatCriticalRadiusHighRes=(np.argmax(np.array(vNumberofShollIntersectionsALL))+1).tolist()
        vNewFilamentStatMaxIntersectionsHighRes=(np.max(np.array(vNumberofShollIntersectionsALL))).tolist()

    ###############################################################################
        #Calculate slope???Linear regression
        #From Critical radius to outer ring
        # x = vNumberofShollIntersectionsALL[vNewFilamentStatMaxIntersectionsHighRes:len(vNumberofShollIntersectionsALL)+1]
        # y = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))

        # zLinearRegressionSlope, zLinearRegressionIntercept, zLinearRegression_r, zLinearRegression_p, zLinearRegression_std_err = stats.linregress(x, y)

        # def myfunc(x):
        #   return slope * x + intercept

        # mymodel = list(map(myfunc, x))

        # plt.scatter(x, y)
        # plt.plot(x, mymodel)
        # plt.show()

    ###############################################################################
        #Logaithmic Regression
        # import math
        # from math import log

        # from scipy.stats import linregress


        # # distal list of sholl intersection pe 1um after max interval
        # zDistIndX = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))
        # zDistNumberShollInt = [ vNumberofShollIntersectionsALL[i-1] for i in x]

        # # proximal list of sholl intersection pe 1um before max interval
        # zProxIndX = list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL)))
        # zProxNumberShoollInt = [ vNumberofShollIntersectionsALL[i-1] for i in x]
        # #Linear slope of the line
        # zProxSlope = linregress(zProxIndX, zProxNumberShoollInt)
        # zDistSlope = linregress(zDistIndX, zDistNumberShollInt)


        # # proximal list of sholl intersection pe 1um before max interval
        # zProxIndX = np.array(list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL))))
        # zProxNumberShollInt = np.log(np.array([ vNumberofShollIntersectionsALL[i-1] for i in x]))
        # # distal list of sholl intersection pe 1um after max interval
        # zDistIndX = np.array(list(range(vNewFilamentStatMaxIntersectionsHighRes, len(vNumberofShollIntersectionsALL))))
        # zDistNumberShollInt = np.log(np.array([ vNumberofShollIntersectionsALL[i-1] for i in x]))
        # #linear repression log log plot
        # zProxSlope, zProxIntercept = np.polyfit(np.log(zProxIndX), zProxNumberShollInt, 1)
        # zDistSlope, zDistIntercept = np.polyfit(np.log(zDistIndX), zDistNumberShollInt, 1)








        # x=[log(i) for i in x]
        # xNEW=[x[i]/(y[i]*y[i]*math.pi) for i in range(len(x))]

        #fit the model
        # plt.scatter(x, y)
        # plt.show()
        # fit = np.polyfit(np.array(xNEW), np.array(y), 1)

        # #view the output of the model
        # print(fit)



    ###############################################################################
    ###############################################################################
    #Spilt Dendrite segments at the point of Sholl intersection
        if qOptionShollDendrites == 1:
        #Create new label/statistic to id
            #Spilt out Final defined sholl spheres to new value
            # vFinalShollSpheres=[vSpotPositionAllShollSpheresPerFilament[i] for i in [i-1 for i in zShollLabelsFinal]]
            #flatten all Sholl intersection to single list
            vSpotPositionAllShollSpheresFlat = [x for xs in vSpotPositionAllShollSpheresPerFilament for x in xs]

        #Find spot on each filament and delete the spot to split dendrite at the sholl intersection
            for qIndexShollPosition in range(len(vSpotPositionAllShollSpheresFlat)):
                zShollxyzCurrent=vSpotPositionAllShollSpheresFlat[qIndexShollPosition]
                zShollxyz=np.array(vFilamentsXYZ).T
                zClosestDistanced3D = ( (zShollxyz[0] - zShollxyzCurrent[0]) ** 2 + (zShollxyz[1] - zShollxyzCurrent[1]) ** 2 + (zShollxyz[2] - zShollxyzCurrent[2]) ** 2) ** 0.5#for3D
                zClosest_index = np.argmin(zClosestDistanced3D)
                zClosest = vFilamentsXYZ[zClosest_index]
                #Find/delete Edges Index from original FilamentEdges
                # zNewFilamentsEdges=(np.delete(zNewFilamentsEdges,zClosest_index,0)).tolist()
                try:
                    zNewFilamentsEdges=(np.delete(zNewFilamentsEdges, np.where(zNewFilamentsEdges==zClosest_index)[0][0],0)).tolist()
                except:
                    x=1

        #Create a NEW Filament object with dendrite segments split
            vNewFilaments=vImarisApplication.GetFactory().CreateFilaments()
            vNewFilaments.AddFilament(zNewFilamentsXYZ, zNewFilamentsRadius, zNewFilamentsTypes, zNewFilamentsEdges, vFilamentsIndexT)
            vNewFilaments.SetName('Sholl Dendrites (ID: ' + str(vFilamentIds[vFilamentCountActual-1])+')')

            vNewFilaments.SetName('FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1])+' -- Sholl Dendrites')

            vShollDendrites.AddChild(vNewFilaments, -1)
            vImarisApplication.GetSurpassScene().AddChild(vShollDendrites, -1)

        #Get Dendrite position stats
            zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Dendrite Position X').mValues
            zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Dendrite Position Y').mValues
            zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Dendrite Position Z').mValues
            zStatisticDendriteLength= vNewFilaments.GetStatisticsByName('Dendrite Length').mValues
            zStatisticDendriteIds = vNewFilaments.GetStatisticsByName('Dendrite Position X').mIds
            if zStatisticDendriteLength == []:
                aVersionValue = 10
                zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Segment Position X').mValues
                zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Segment Position Y').mValues
                zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Segment Position Z').mValues
                zStatisticDendriteLength= vNewFilaments.GetStatisticsByName('Segment Length').mValues
                zStatisticDendriteIds = vNewFilaments.GetStatisticsByName('Segment Position X').mIds

        #Measure distance from each Dendrite position to starting point
             #Collate XYZ positions in to a single list
            zNewDendritesPosXYZ=[list(t) for t in zip(zStatisticDendritePosX, zStatisticDendritePosY, zStatisticDendritePosZ)]
            zDistanceDendriteListValues=cdist([vBeginningVertexPositionXYZ], zNewDendritesPosXYZ)
            zDistanceDendriteListValues=zDistanceDendriteListValues.transpose()

        #CreateLabels for each Sholl sphere
            # scount=0
            # zShollLabelsAll = [20]
            # i=0
            vNewFilamentsStatId=[]
            vNewFilamentsStatLength=[]
            vNewFilamentsStatShollSphere=[]

            zShollLabelsInt=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+2), vShollRadius))

            # zShollLabelsInt = [int(i) for i in zShollLabelsFinal]
            zShollLabelsInt.insert(0,0)#insert a zero at start of list
            vLabelIndices=[]
            for i in range (len(zShollLabelsInt)-1):
                zDistanceDendriteListValues=np.where((zDistanceDendriteListValues > zShollLabelsInt[i]) &
                                 (zDistanceDendriteListValues <= zShollLabelsInt[i+1]),zShollLabelsInt[i+1], zDistanceDendriteListValues)
        ###Creating new statistics for segmented dendrite length
                vNewFilamentsStatLength.append(sum([zStatisticDendriteLength[i]
                                                    for i in np.where(zDistanceDendriteListValues==zShollLabelsInt[i+1])[0].tolist()]))

        ###############################################################################
            #Add Sholl Statistics
            vNewFilamentsStatvIds=list(range(len(zStatisticDendriteIds)))
            vNewFilamentsStatUnits=['']*(len(zStatisticDendriteIds))
            if aVersionValue < 10:
                vNewFilamentsStatFactors=(['Dendrite']*len(zStatisticDendriteIds), [str(vFilamentsIndexT+1)]*len(zStatisticDendriteIds))
            else:
                vNewFilamentsStatFactors=(['Segment']*len(zStatisticDendriteIds), [str(vFilamentsIndexT+1)]*len(zStatisticDendriteIds))
            vNewFilamentsStatFactorName=['Category','Time']
        #######################
            vNewFilamentsIdStat=[vFilamentIds[vFilamentCountActual-1]-100000000]*len(zStatisticDendriteIds)
            vNewFilamentsStatNames=[' xFilament ID']*(len(zStatisticDendriteIds))
            vNewFilaments.AddStatistics(vNewFilamentsStatNames, vNewFilamentsIdStat,
                                  vNewFilamentsStatUnits, vNewFilamentsStatFactors,
                                  vNewFilamentsStatFactorName, zStatisticDendriteIds)
        ########################
            vNewFilamentsStatShollSphere=zDistanceDendriteListValues.tolist()
            vNewFilamentsStatShollSphere = [x for xs in vNewFilamentsStatShollSphere for x in xs]
            vNewFilamentsStatNames=[' Sholl Sphere']*(len(zStatisticDendriteIds))
            vNewFilaments.AddStatistics(vNewFilamentsStatNames, vNewFilamentsStatShollSphere,
                                  vNewFilamentsStatUnits, vNewFilamentsStatFactors,
                                  vNewFilamentsStatFactorName, zStatisticDendriteIds)

    ###############################################################################
    ###############################################################################

    ###############################################################################
    #Create Sholl Spots object for each filament with new stats
        vNewShollSpotsPerFilament = vImarisApplication.GetFactory().CreateSpots()

        # vFinalShollSpheres=[vSpotPositionAllShollSpheresPerFilament[i] for i in [i-1 for i in zShollLabelsFinal]]
        #may need to flatten spot list of lists
        vSpotPositionAllShollSpheresPerFilament = [num for elem in vSpotPositionAllShollSpheresPerFilament for num in elem]


        vNewShollSpotsPerFilament.Set(vSpotPositionAllShollSpheresPerFilament,
                              [vFilamentsIndexT]*len(vSpotPositionAllShollSpheresPerFilament),
                              [1]*len(vSpotPositionAllShollSpheresPerFilament))
        vNewShollSpotsPerFilament.SetName(' Sholl - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewShollSpotsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
        vShollResult2.AddChild(vNewShollSpotsPerFilament, -1)
        vImarisApplication.GetSurpassScene().AddChild(vShollResult2, -1)

    #Create Spots for each Terminal Point
        if qOptionTerminalPoints == 1 and qOptionMergePoints == 0:
            vNewSpotsTerminalPointsPerFilament = vImarisApplication.GetFactory().CreateSpots()
            vNewSpotsTerminalPointsPerFilament.Set(wFilamentTerminalPointsNEWCurrent.tolist(),
                                  [vFilamentsIndexT]*len(wFilamentTerminalPointsNEWCurrent.tolist()),
                                  [1]*len(wFilamentTerminalPointsNEWCurrent.tolist()))
            vNewSpotsTerminalPointsPerFilament.SetName(' TerminalPoints - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
            zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
            vNewSpotsTerminalPointsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
            vSpotFilamentPoints.AddChild(vNewSpotsTerminalPointsPerFilament, -1)
            vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)

    #Create Spots for each Branch Point
        if qOptionBranchPoints == 1 and qOptionMergePoints == 0:
            vNewSpotsBranchPointsPerFilament = vImarisApplication.GetFactory().CreateSpots()
            vNewSpotsBranchPointsPerFilament.Set(wFilamentBranchPointsNEWCurrent.tolist(),
                                  [vFilamentsIndexT]*len(wFilamentBranchPointsNEWCurrent.tolist()),
                                  [1]*len(wFilamentBranchPointsNEWCurrent.tolist()))
            vNewSpotsBranchPointsPerFilament.SetName(' BranchPoints - FilamentID:'+ str(vFilamentIds[vFilamentCountActual-1]))
            zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
            vNewSpotsBranchPointsPerFilament.SetColorRGBA(zRandomColor)#Set Random color
            vSpotFilamentPoints.AddChild(vNewSpotsBranchPointsPerFilament, -1)
            vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)

        #############################################################
        #Add new stats
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsvIds=list(range(len(vSpotPositionAllShollSpheresPerFilament)))
        vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsStatFactors=(['Spot']*len(vSpotPositionAllShollSpheresPerFilament), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        ###########################
        vSpotsStatNames=[' Sholl Sphere Distance']*len(vSpotPositionAllShollSpheresPerFilament)
        vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, vNewStatSpotShollDistance,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)
        ###########################
        vSpotsStatUnits=['']*len(vSpotPositionAllShollSpheresPerFilament)
        vSpotsStatNames=[' Number of Intersections']*len(vSpotPositionAllShollSpheresPerFilament)
        vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, vNewStatSpotNumberShollIntersections,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)

    ###############################################################################
    #Add Overall statistics for sum dendrite length per sholl sphere
            #Insert an overall Statistics
        vOverallStatIds=[int(-1)]
        vOverallStatUnits_um=['um']*vSizeT
        vOverallStatUnits=['']*vSizeT
        vOverallStatFactorsTime=list(range(1,vSizeT+1))
        vOverallStatFactors=[['Overall'],[str(i) for i in vOverallStatFactorsTime]]
        vOverallStatFactorNames=['FactorName','Time']
    ###########
    #Calculate and report the Critical Radius (radius with the highest density)
        vNewFilamentStatCriticalRadius=[vNewStatSpotShollDistance[vNewStatSpotNumberShollIntersections.index(max(vNewStatSpotNumberShollIntersections))]]
        vNewFilamentStatMaxIntersections=[max(vNewStatSpotNumberShollIntersections)]

        vOverallStatNames = [' Sholl Critical Radius']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, vNewFilamentStatCriticalRadius,
                                                vOverallStatUnits_um, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Max # Intersections']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, vNewFilamentStatMaxIntersections,
                                                vOverallStatUnits, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Critical Radius HighRes']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentStatCriticalRadiusHighRes],
                                                vOverallStatUnits_um, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)
        vOverallStatNames = [' Sholl Max # Intersections HighRes']
        vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentStatMaxIntersectionsHighRes],
                                                vOverallStatUnits, vOverallStatFactors,
                                                vOverallStatFactorNames, vOverallStatIds)

    ###############################################################################
    ###############################################################################
    #Calculate sholl intersection distance on dendrite to starting point
    ###############################################################################
    # #Find Spot close to filament and measure distance along path to starting point
    # #Make spot position conect to filament as spine attachment point

        if vSpotPositionAllShollSpheresPerFilament!=[]:
            if vBeginningVertex !=-1:
                wNewFilamentsEdges=list(vFilamentsEdges)
                wNewFilamentsRadius=list(vFilamentsRadius)
                wNewFilamentsXYZ=list(vFilamentsXYZ)
                wNewFilamentsTypes=list(vTypes)

                wNewFilamentsEdgesTerminal=list(vFilamentsEdges)
                wNewFilamentsRadiusTerminal=list(vFilamentsRadius)
                wNewFilamentsXYZTerminal=list(vFilamentsXYZ)
                wNewFilamentsTypesTerminal=list(vTypes)

                wNewFilamentsEdgesBranch=list(vFilamentsEdges)
                wNewFilamentsRadiusBranch=list(vFilamentsRadius)
                wNewFilamentsXYZBranch=list(vFilamentsXYZ)
                wNewFilamentsTypesBranch=list(vTypes)

                #Create array of distance measures to original filament points
                wSpotToAllFilamentDistanceArrayOriginal=cdist((np.array(vSpotPositionAllShollSpheresPerFilament)),vFilamentsXYZ)
                wSpotBranchPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentBranchPointsNEWCurrent,vFilamentsXYZ)
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal=cdist(wFilamentTerminalPointsNEWCurrent,vFilamentsXYZ)

                wBranchIdxBlock = np.where(wSpotBranchPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()
                wTerminalIdxBlock = np.where(wSpotTerminalPointToAllFilamentDistanceArrayOriginal==0)[1].tolist()

                # #Replace zeros with large number
                wSpotToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,wBranchIdxBlock]=9999
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,wTerminalIdxBlock]=9999

                #Replace Starting point from FilamentXYZ with col of large 9999
                # (np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]
                wSpotBranchPointToAllFilamentDistanceArrayOriginal[:,[(np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]]]=9999
                wSpotTerminalPointToAllFilamentDistanceArrayOriginal[:,[(np.where(np.array(vFilamentsXYZ) == wFilamentStartingPointsNEWCurrent[0]))[0][0]]]=9999

                #For each spot, find index on filament of closest point
                wSpotsFilamentClosestDistancePointIndex=np.argmin(wSpotToAllFilamentDistanceArrayOriginal, axis=1)
                wSpotsBranchPointsFilamentClosestDistancePointIndex=np.argmin(wSpotBranchPointToAllFilamentDistanceArrayOriginal, axis=1)
                wSpotsTerminalPointsFilamentClosestDistancePointIndex=np.argmin(wSpotTerminalPointToAllFilamentDistanceArrayOriginal, axis=1)

                #loop for each spot within threshold
                #append new filament and create list of new spots
                for i in range (len(vSpotPositionAllShollSpheresPerFilament)):
                    wNewFilamentsXYZ.append(((np.array(vSpotPositionAllShollSpheresPerFilament))+.00001)[i].tolist())
                    wNewFilamentsRadius.append(1)
                    wNewFilamentsEdges.append([wSpotsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypes.append(1)

                #loop for each Terminal Point
                #append new filament and create list of new spots
                for i in range (len(wFilamentTerminalPointsNEWCurrent)):
                    wNewFilamentsXYZTerminal.append((wFilamentTerminalPointsNEWCurrent+0.00001)[i].tolist())
                    wNewFilamentsRadiusTerminal.append(1)
                    wNewFilamentsEdgesTerminal.append([wSpotsTerminalPointsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypesTerminal.append(1)

                #loop for each Branch Point
                #append new filament and create list of new spots
                for i in range (len(wFilamentBranchPointsNEWCurrent)):
                    wNewFilamentsXYZBranch.append((wFilamentBranchPointsNEWCurrent+0.00001)[i].tolist())
                    wNewFilamentsRadiusBranch.append(1)
                    wNewFilamentsEdgesBranch.append([wSpotsBranchPointsFilamentClosestDistancePointIndex[i],len(vFilamentsRadius)+i])
                    wNewFilamentsTypesBranch.append(1)

                vNewFilament = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilament.AddFilament(wNewFilamentsXYZ, wNewFilamentsRadius, wNewFilamentsTypes, wNewFilamentsEdges, vFilamentsIndexT)
                vNewFilament.SetBeginningVertexIndex(0, vBeginningVertex)

                vNewFilamentBranch = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilamentBranch.AddFilament(wNewFilamentsXYZBranch, wNewFilamentsRadiusBranch, wNewFilamentsTypesBranch, wNewFilamentsEdgesBranch, vFilamentsIndexT)
                vNewFilamentBranch.SetBeginningVertexIndex(0, vBeginningVertex)

                vNewFilamentTerminal = vImarisApplication.GetFactory().CreateFilaments()
                vNewFilamentTerminal.AddFilament(wNewFilamentsXYZTerminal, wNewFilamentsRadiusTerminal, wNewFilamentsTypesTerminal, wNewFilamentsEdgesTerminal, vFilamentsIndexT)
                vNewFilamentTerminal.SetBeginningVertexIndex(0, vBeginningVertex)

    ###########
        #Grab New Filament Spine Statistics for attachment point distance.
                for aIndex in range(3):#Loop for each
                    # vNewFilamentStatistics=[]
                    if aIndex==0:
                        vNewFilamentSpineAttPtDistSET = vNewFilament.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilament.GetStatisticsByName('Spine Attachment Pt Position X')
                    if aIndex==1:
                        vNewFilamentSpineAttPtDistSET = vNewFilamentTerminal.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilamentTerminal.GetStatisticsByName('Spine Attachment Pt Position X')
                    if aIndex==2:
                        vNewFilamentSpineAttPtDistSET = vNewFilamentBranch.GetStatisticsByName('Spine Attachment Pt Distance')
                        vNewFilamentSpineAttPtPosXSET = vNewFilamentBranch.GetStatisticsByName('Spine Attachment Pt Position X')

                    vNewFilamentSpineAttPtDistValues = vNewFilamentSpineAttPtDistSET.mValues
                    vNewFilamentSpineAttPtDistIds = vNewFilamentSpineAttPtDistSET.mIds
                    vNewFilamentSpineAttPtPosXValues = vNewFilamentSpineAttPtPosXSET.mValues
                    vNewFilamentSpineAttPtPosXIds = vNewFilamentSpineAttPtPosXSET.mIds

                    if aIndex==0:
                    #Collate all Sholl spots for each filament
                        for i in range (len(vSpotPositionAllShollSpheresPerFilament)):
                            wCompleteShollSpotDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsFilamentClosestDistancePointIndex[i]][0])])])

                    if aIndex==1:
                    #Collate for Terminal Points
                        for i in range (len(wFilamentTerminalPointsNEWCurrent)):
                            wCompleteTerminalPointsDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsTerminalPointsFilamentClosestDistancePointIndex[i]][0])])])
                            wCompleteTerminalPointsDistAlongFilamentStatALL.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsTerminalPointsFilamentClosestDistancePointIndex[i]][0])])])

                            vLabelIndices=list(range(len(wCompleteTerminalPointsDistAlongFilamentStatWorking)))
                            for j in range (len(vLabelIndices)):
                                vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                                              'FilamentIds',
                                                                              str(vFilamentIds[aFilamentIndex]))
                                wLabelListTerminalPoints.append(vLabelCreate)

                    if aIndex==2:
                    #Collate for Branch Points
                        for i in range (len(wFilamentBranchPointsNEWCurrent)):
                            wCompleteBranchPointsDistAlongFilamentStatWorking.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsBranchPointsFilamentClosestDistancePointIndex[i]][0])])])
                            wCompleteBranchPointsDistAlongFilamentStatALL.append(vNewFilamentSpineAttPtDistValues[vNewFilamentSpineAttPtDistIds.index(vNewFilamentSpineAttPtPosXIds[vNewFilamentSpineAttPtPosXValues.index(wNewFilamentsXYZ[wSpotsBranchPointsFilamentClosestDistancePointIndex[i]][0])])])

                            vLabelIndices=list(range(len(wCompleteBranchPointsDistAlongFilamentStatWorking)))
                            for j in range (len(vLabelIndices)):
                                vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                                              'FilamentIds',
                                                                              str(vFilamentIds[aFilamentIndex]))
                                wLabelListBranchPoints.append(vLabelCreate)

            #For  Filament stat
            vNewStatFilamentTerminalPointDistToSomaMax = max(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentTerminalPointDistToSomaMean = mean(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentBranchPointDistToSomaMax = max(wCompleteTerminalPointsDistAlongFilamentStatWorking)
            vNewStatFilamentBranchPointDistToSomaMean = mean(wCompleteTerminalPointsDistAlongFilamentStatWorking)

            vNewStatCompleteFilamentBranchPointDistToSomaMean.append(vNewStatFilamentBranchPointDistToSomaMean)
            vNewStatCompleteFilamentTerminalPointDistToSomaMean.append(vNewStatFilamentTerminalPointDistToSomaMean)

            vNewStatCompleteFilamentTerminalPointDistToSomaMax.append(vNewStatFilamentTerminalPointDistToSomaMax)

            #############################################################
            #Add new Terminal stats
            if qOptionBranchPoints == 1 and qOptionMergePoints == 0:
                vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wFilamentBranchPointsNEWCurrent)
                vSpotsvIds=list(range(len(wFilamentBranchPointsNEWCurrent)))
                vSpotsStatUnits=['um']*len(wFilamentBranchPointsNEWCurrent)
                vSpotsStatFactors=(['Spot']*len(wFilamentBranchPointsNEWCurrent), [str(x) for x in vSpotsTimeIndex] )
                vSpotsStatFactorName=['Category','Time']
                #Create stats for distance along dendrite
                vSpotsStatUnits=['um']*len(wFilamentBranchPointsNEWCurrent)
                vSpotsStatNames=[' Distance to somaalong dendrite']*len(wFilamentBranchPointsNEWCurrent)
                vNewSpotsBranchPointsPerFilament.AddStatistics(vSpotsStatNames, wCompleteBranchPointsDistAlongFilamentStatWorking,
                                              vSpotsStatUnits, vSpotsStatFactors,
                                              vSpotsStatFactorName, vSpotsvIds)
    ########################
            if qOptionTerminalPoints == 1 and qOptionMergePoints == 0:
                vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wFilamentTerminalPointsNEWCurrent)
                vSpotsvIds=list(range(len(wFilamentTerminalPointsNEWCurrent)))
                vSpotsStatUnits=['um']*len(wFilamentTerminalPointsNEWCurrent)
                vSpotsStatFactors=(['Spot']*len(wFilamentTerminalPointsNEWCurrent), [str(x) for x in vSpotsTimeIndex] )
                vSpotsStatFactorName=['Category','Time']
                vSpotsStatNames=[' Distance to soma along dendrite']*len(wFilamentTerminalPointsNEWCurrent)
                vNewSpotsTerminalPointsPerFilament.AddStatistics(vSpotsStatNames, wCompleteTerminalPointsDistAlongFilamentStatWorking,
                                              vSpotsStatUnits, vSpotsStatFactors,
                                              vSpotsStatFactorName, vSpotsvIds)

    ###########################
    #Create stats for distance along dendrite to starting point
            vSpotsTimeIndex=[vFilamentsIndexT+1]*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsvIds=list(range(len(vSpotPositionAllShollSpheresPerFilament)))
            vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatFactors=(['Spot']*len(vSpotPositionAllShollSpheresPerFilament), [str(x) for x in vSpotsTimeIndex] )
            vSpotsStatUnits=['um']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatNames=[' Distance to Starting Point']*len(vSpotPositionAllShollSpheresPerFilament)
            vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, wCompleteShollSpotDistAlongFilamentStatWorking,
                                          vSpotsStatUnits, vSpotsStatFactors,
                                          vSpotsStatFactorName, vSpotsvIds)
    ################################
            vSpotsStatUnits=['']*len(vSpotPositionAllShollSpheresPerFilament)
            vSpotsStatNames=[' Ratio ShollDistance to Distance to Starting Point']*len(vSpotPositionAllShollSpheresPerFilament)
            vNewShollSpotsPerFilament.AddStatistics(vSpotsStatNames, [vNewStatSpotShollDistance[i]/wCompleteShollSpotDistAlongFilamentStatWorking[i] for i in range(len(vNewStatSpotShollDistance))],
                                          vSpotsStatUnits, vSpotsStatFactors,
                                          vSpotsStatFactorName, vSpotsvIds)

    ###############################################################################
    ###############################################################################

    #loop for each sphere and create overall stat
        #main loop adds one for last sholl ring
            zShollLabelsInt=list(range(vShollRadius, vShollRadius*(wApproxNumSpheres+2), vShollRadius))
            for i in range (len(zShollLabelsInt)):
                if qOptionShollDendrites == 1:
                    vOverallStatNames = [' Sholl Ring Dendrite Length Sum - ' + '0'+ str(zShollLabelsInt[i]) + ' um']
                    if zShollLabelsInt[i]>=100:
                        vOverallStatNames = [' Sholl Ring Dendrite Length Sum - ' + str(zShollLabelsInt[i]) + ' um']
                    vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNewFilamentsStatLength[i]],
                                              vOverallStatUnits_um, vOverallStatFactors,
                                              vOverallStatFactorNames, vOverallStatIds)

            #Loop just the sholl sphere values
            # if i > 0 and i < len(zShollLabelsInt)-1:
            if i < len(zShollLabelsInt)-1:

                # vOverallStatNames = [' Number Intersections - ' + str(zShollLabelsInt[i]) + ' um Sholl Sphere']
                # vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, [vNumberOfShollIntersectionPerSpherePerFilament[i-1]],
                #                           vOverallStatUnits, vOverallStatFactors,
                #                           vOverallStatFactorNames, vOverallStatIds)

                #Set Sholl sphere Labels for each filament
                vLabelIndices = (np.where(np.array(vNewStatSpotShollDistance)==zShollLabelsInt[i]))[0].tolist()
                wLabelList=[]
                if zShollLabelsInt[i] < 10:
                    zLabelName = ('00' + str(zShollLabelsInt[i]))
                elif zShollLabelsInt[i] < 100 and zShollLabelsInt[i] >= 10:
                    zLabelName = ('0' + str(zShollLabelsInt[i]))
                else:
                    zLabelName = str(zShollLabelsInt[i])


                for j in range (len(vLabelIndices)):
                    vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j], "Sholl Intersections", ' ' + zLabelName)
                    wLabelList.append(vLabelCreate)
                vNewShollSpotsPerFilament.SetLabels(wLabelList)


    ###############################################################################
    ###############################################################################
    #Calcualte Arbor Orientation Index
    #Equation:
    #    AOE = (Number of Shollpoints in vertical Quadrants -Number of Shollpoints in horizaontal Quadrants) / Total Numerb of Sholl points
    #AOE =  1  vertically aligned
    #AOE = -1  horizontally aligned
    #AOE =  0 are equal in all directions
    #     vSpotPositionAllShollSpheresPerFilamentAdjusted=[vSpotPositionAllShollSpheresPerFilament[i] - vBeginningVertexPositionXYZ
    #                                                      for i in range(len(vSpotPositionAllShollSpheresPerFilament))]

    #Use a reference frame to set the orientation space to measure from
    #Extract out the sholl position relative to the Ref Frame
    #zStatisticDendritePosX = vNewFilaments.GetStatisticsByName('Segment Position X Reference frame').mValues
    #zStatisticDendritePosY = vNewFilaments.GetStatisticsByName('Segment Position Y Reference frame').mValues
    #zStatisticDendritePosZ = vNewFilaments.GetStatisticsByName('Segment Position Z Reference frame').mValues




    #If refernce is set to orient the orign axis
        #Grab New Filament Spine Statistics for attachment point distance.
        # vNewShollSpotsPerFilamentStatistics = vNewSpots.GetStatistics()
        # vNewShollSpotsPerFilamentStatNames = vNewShollSpotsPerFilamentStatistics.mNames
        # vNewShollSpotsPerFilamentStatValues = vNewShollSpotsPerFilamentStatistics.mValues
        # vNewShollSpotsPerFilamentStatIds = vNewShollSpotsPerFilamentStatistics.mIds



    #Maybe something different for 3D Sholl???




    ###############################################################################
    ###############################################################################
    #Calculate Convexhull and Delauney 2d and 3D
    #convert xyz position into closest pixel coordinates
        wConversionX = (vDataMax[0]-vDataMin[0])/vDataSize[0]
        wConversionY = (vDataMax[1]-vDataMin[1])/vDataSize[1]
        wConversionZ = (vDataMax[2]-vDataMin[2])/vDataSize[2]
        if qOptionConvexHull == 1:

            if qOptionConvexHullTerminal == 1:
                vFilamentXYZPointsConvexHullPixelPos = np.copy(wFilamentTerminalPointsNEWCurrent)
                vFilamentXYZPointsConvexHullPixelPos = np.vstack([vFilamentXYZPointsConvexHullPixelPos, wFilamentStartingPointsNEWCurrent])
                vFilamentsXYZArray = np.array(vFilamentXYZPointsConvexHullPixelPos)
            else:
                vFilamentsXYZArray = np.array(vFilamentsXYZ)
                vFilamentXYZPointsConvexHullPixelPos = np.copy(vFilamentsXYZArray)

            vFilamentXYZPointsConvexHullPixelPos[:,0] = (vFilamentXYZPointsConvexHullPixelPos[:,0]-vDataMin[0])/wConversionX
            vFilamentXYZPointsConvexHullPixelPos[:,1] = (vFilamentXYZPointsConvexHullPixelPos[:,1]-vDataMin[1])/wConversionY
            vFilamentXYZPointsConvexHullPixelPos[:,2] = (vFilamentXYZPointsConvexHullPixelPos[:,2]-vDataMin[2])/wConversionZ
            vFilamentXYZPointsConvexHullPixelPos = vFilamentXYZPointsConvexHullPixelPos.astype(int)

            vFilamentXYZPointsConvexHullPixelPos[:,0][np.where(vFilamentXYZPointsConvexHullPixelPos[:,0] == vDataSize[0])[0]]=vDataSize[0]-1
            vFilamentXYZPointsConvexHullPixelPos[:,1][np.where(vFilamentXYZPointsConvexHullPixelPos[:,1] == vDataSize[1])[0]]=vDataSize[1]-1
            # vFilamentXYZPointsConvexHullPixelPos[:,2][np.where(vFilamentXYZPointsConvexHullPixelPos[:,2] == vDataSize[2])[0]]=vDataSize[2]-1

            #Test is volume is 2D
            if vDataSize[2] == 1:
                #for stat calculation
                vFilamentsXYZArray2D = np.delete(vFilamentsXYZArray,2,1)
                wFilamentConvexHullCurrentStat = ConvexHull(vFilamentsXYZArray2D)

                vFilamentXYZPointsCurrentPixelPos2D = np.delete(vFilamentXYZPointsConvexHullPixelPos,2,1)
                wFilamentConvexHullCurrent = ConvexHull(vFilamentXYZPointsCurrentPixelPos2D)
                wFilamentConvexHullDelaunyCurrent = Delaunay(vFilamentXYZPointsCurrentPixelPos2D[wFilamentConvexHullCurrent.vertices])

            else:
                wFilamentConvexHullCurrentStat = ConvexHull(vFilamentsXYZArray)

        #Calculate Dendritic Field Size (2D and 3D) and surface area...from ConvexHull
            wNewStatConvexHullVolumePerFilament.append(wFilamentConvexHullCurrentStat.volume)
            wNewStatConvexHullAreaPerFilament.append(wFilamentConvexHullCurrentStat.area)

            progress_bar2['value'] = int((aFilamentIndex+.5)/vNumberOfFilaments*100) #  % out of 100
            qProgressBar.update()

        #create new Dataset full volume
            vDataSet = vImarisApplication.GetFactory().CreateDataSet()
            vDataSet.Create(vType, vDataSize[0], vDataSize[1], vDataSize[2], 1, 1)
            vDataSet.SetExtendMinX(vDataMin[0])
            vDataSet.SetExtendMinY(vDataMin[1])
            vDataSet.SetExtendMinZ(vDataMin[2])
            vDataSet.SetExtendMaxX(vDataMax[0])
            vDataSet.SetExtendMaxY(vDataMax[1])
            vDataSet.SetExtendMaxZ(vDataMax[2])
            vDataSet.SetTimePoint(vFilamentsIndexT, vFilamentTimepoint)

        #Create Convex hull mask and generate surface
            if vDataSize[2] == 1:
                #for 2D whole image
                idx = np.stack(np.indices([vDataSize[0],vDataSize[1]]), axis = -1)
                out_idx = np.nonzero(wFilamentConvexHullDelaunyCurrent.find_simplex(idx) + 1)
                vSlice = np.zeros([vDataSize[0],vDataSize[1]])
                vSlice[out_idx] = 1
                #convert to single column per slice for import into Channel
                vSlice = vSlice.flatten('F')
                vIndexZ=0
                #Add mask to DataSet
                vDataSet.SetDataSubVolumeAs1DArrayFloats(vSlice.tolist(),
                                                0,
                                                0,
                                                vIndexZ,
                                                0,
                                                0,
                                                vDataSize[0],
                                                vDataSize[1],
                                                1)
            else:
                #create tuple and flip so that Z is first column, follow by x ,then Y
                points = tuple((vFilamentXYZPointsConvexHullPixelPos[:,2],
                               vFilamentXYZPointsConvexHullPixelPos[:,0],
                               vFilamentXYZPointsConvexHullPixelPos[:,1]))
                image = np.zeros((vDataSize[2],vDataSize[0],vDataSize[1]))

                #Replace Points in blank image for COnvexHull calculation
                image[points] = 1
                #Find Indices in volume where value is >1
                points = np.transpose(np.where(image))
                #Process COnvex hull and Delauney
                hull = ConvexHull(points)
                deln = Delaunay(points[hull.vertices])
                vVolume = np.zeros((vDataSize[2],vDataSize[0],vDataSize[1]))
                #for 3D whole image
                idx = np.stack(np.indices(vVolume.shape), axis = -1)
                out_idx = np.nonzero(deln.find_simplex(idx) + 1)
                #Set value=1 for pixels inside Convexhull
                vVolume[out_idx] = 1

                #loop each Z and creat Convexhull mask channel
                for vIndexZ in range (vDataSize[2]):
                    vSlice = vVolume[vIndexZ].flatten('F')
                    #Add mask to DataSet
                    vDataSet.SetDataSubVolumeAs1DArrayFloats(vSlice.tolist(),
                                                    0,
                                                    0,
                                                    vIndexZ,
                                                    0,
                                                    0,
                                                    vDataSize[0],
                                                    vDataSize[1],
                                                    1)
                    progress_bar3['value'] = int((vIndexZ)/vDataSize[2]*100) #  % out of 100
                    qProgressBar.update()
        #make surface convex hull
            ip = vImarisApplication.GetImageProcessing()
            vConvexHull = ip.DetectSurfaces(vDataSet, [],
                                      0,
                                      vSmoothingFactor,
                                      0,
                                      True,
                                      55,
                                      '')
      #copy surface to sceneobject named vSurfaceHull
            vConvexHull.CopySurfacesToSurfaces([0], vSurfaceHull)

    ##############################################################################
    ###############################################################################
        if qOptionRegularityIndex == 1:
        #Calculation of Mean Nearest Neighbor based on branch points and terminal points
            #Create a set of Random Spots, same numebr of branch points or terminal points
            #limit creation of random spot to be within the MinMax of XYZ of the filament points
            zArray=np.array(vFilamentsXYZ)
            isFilament2D=False
            zRandomLimitsMin=np.min(zArray, 0)
            zRandomLimitsMax=np.max(zArray, 0)
            zRandomSpotsTerminal=[]
            zRandomSpotsNode=[]
            zAverageNNBranchPointRandomALL = []
            zAverageNNTerminaTPointRandomALL=[]
            zCurrentFilamentsRegularityIndexTP = []
            zCurrentFilamentsRegularityIndexBP = []

            if len(wFilamentBranchPointsNEWCurrent) > 3:
            # if np.shape(wFilamentBranchPoints)[0] >3:
                zArrayNodes=cdist(wFilamentBranchPointsNEWCurrent,wFilamentBranchPointsNEWCurrent)
                zArrayNodesMin=np.where(zArrayNodes>0, zArrayNodes, np.inf).min(axis=1)
                zMeanNNBranchPoint=np.mean(zArrayNodesMin)
                for iRandom in range (10):
                    zRandomSpotsNode=[]
                    for i in range(3):
                        zRandomSpotsNode.append(np.random.uniform(low=zRandomLimitsMin[i], high=zRandomLimitsMax[i], size= np.shape(wFilamentBranchPointsNEWCurrent)[0]))
                    zRandomSpotsNode=np.transpose(np.array(zRandomSpotsNode))
                    #Find if set of Random Spots falls inside Convex hull on Filament
                    if (np.all(zArray[:,2] == zArray[0][2]))==True:
                        zArray=np.delete(zArray,2,1)
                        zRandomSpotsNode=np.delete(zRandomSpotsNode,2,1)
                        isFilament2D=True
                    zHullDelaunay = Delaunay(zArray)
                    #Create Boolean arguement to define if in Convex hull
                    zRandomSpotTestNode=np.array(zHullDelaunay.find_simplex(zRandomSpotsNode)>=0)
                    #Keep True, replace false with new random spot
                    if np.any(zRandomSpotTestNode):
                        #find indices that are True
                        zBrokenRandomSpots=np.where(zRandomSpotTestNode==False)
                        for i in range (len(zBrokenRandomSpots)):
                            #Create new random spot
                            zNEWRandomSpot=[]
                            for j in range(3):
                                zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                            zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                            if isFilament2D:
                                zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Test if inConvex hull
                            while (zHullDelaunay.find_simplex(zNEWRandomSpot)>=0)==False:
                                #Create new random spot
                                zNEWRandomSpot=[]
                                for j in range(3):
                                    zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                                zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                                if isFilament2D:
                                    zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Replace entire row with new positions
                            zRandomSpotsNode[zBrokenRandomSpots[0][i],:]=zNEWRandomSpot
                    #Calculation of Mean Nearest Neighbor based on branch points and terminal points
                    zArrayNodes=cdist(zRandomSpotsNode,zRandomSpotsNode)
                    zArrayNodesMin=np.where(zArrayNodes>0, zArrayNodes, np.inf).min(axis=1)
                    zAverageNNBranchPointRandom=np.mean(zArrayNodesMin)

                    #Collate all NN from the 10 random rounds....
                    zAverageNNBranchPointRandomALL.append(zAverageNNBranchPointRandom)
                #Calculation of Regulatiry Index
                zAllFilamentsRegularityIndexBP.append(zMeanNNBranchPoint/mean(zAverageNNBranchPointRandomALL))
                zCurrentFilamentsRegularityIndexBP.append(zMeanNNBranchPoint/mean(zAverageNNBranchPointRandomALL))

            else:
                zAllFilamentsRegularityIndexBP.append(0)
                zCurrentFilamentsRegularityIndexBP.append(0)
        ###############################################################################
            if len(wFilamentTerminalPointsNEWCurrent) > 3:
            # if np.shape(wFilamentTerminalPointsNEWCurrent)[0] >3:
                zArrayTerminal=cdist(wFilamentTerminalPointsNEWCurrent,wFilamentTerminalPointsNEWCurrent)
                zArrayTerminalMin=np.where(zArrayTerminal>0, zArrayTerminal, np.inf).min(axis=1)
                zMeanNNTerminalPoint=np.mean(zArrayTerminalMin)
                for iRandom in range (10):
                    zRandomSpotsTerminal=[]
                    for i in range(3):
                        zRandomSpotsTerminal.append(np.random.uniform(low=zRandomLimitsMin[i], high=zRandomLimitsMax[i], size= np.shape(wFilamentTerminalPointsNEWCurrent)[0]))
                    zRandomSpotsTerminal=np.transpose(np.array(zRandomSpotsTerminal))
                    #Find if set of Random Spots falls inside Convex hull on Filament
                    if (np.all(zArray[:,2] == zArray[0][2]))==True:
                        zArray=np.delete(zArray,2,1)
                        zRandomSpotsTerminal=np.delete(zRandomSpotsTerminal,2,1)
                        isFilament2D=True
                    zHullDelaunay = Delaunay(zArray)
                    #Create Boolean arguement to define if in Convex hull
                    zRandomSpotTestTerminal=np.array(zHullDelaunay.find_simplex(zRandomSpotsTerminal)>=0)
                    if np.any(zRandomSpotTestTerminal):
                        #find indices that are True
                        zBrokenRandomSpots=np.where(zRandomSpotTestTerminal==False)
                        for i in range (len(zBrokenRandomSpots)):
                            #Create new random spot
                            zNEWRandomSpot=[]
                            for j in range(3):
                                zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                            zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                            if isFilament2D:
                                zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Test if inConvex hull
                            while (zHullDelaunay.find_simplex(zNEWRandomSpot)>=0)==False:
                                #Create new random spot
                                zNEWRandomSpot=[]
                                for j in range(3):
                                    zNEWRandomSpot.append(np.random.uniform(low=zRandomLimitsMin[j], high=zRandomLimitsMax[j], size= 1))
                                zNEWRandomSpot=np.transpose(np.array(zNEWRandomSpot))
                                if isFilament2D:
                                    zNEWRandomSpot=np.delete(zNEWRandomSpot,2,1)
                            #Replace entire row with new positions
                            zRandomSpotsTerminal[zBrokenRandomSpots[0][i],:]=zNEWRandomSpot
                    #Calculation of Mean Nearest Neighbor based on branch points and terminal points
                    zArrayTerminal=cdist(zRandomSpotsTerminal,zRandomSpotsTerminal)
                    zArrayTerminalMin=np.where(zArrayTerminal>0, zArrayTerminal, np.inf).min(axis=1)
                    zAverageNNTerminaTPointRandom=np.mean(zArrayTerminalMin)
                    #Collate all NN from the 10 random rounds....
                    zAverageNNTerminaTPointRandomALL.append(zAverageNNTerminaTPointRandom)
                #Calculation of Regulatiry Index
                zAllFilamentsRegularityIndexTP.append(zMeanNNTerminalPoint/mean(zAverageNNTerminaTPointRandomALL))
                zCurrentFilamentsRegularityIndexTP.append(zMeanNNTerminalPoint/mean(zAverageNNTerminaTPointRandomALL))
            else:
                zAllFilamentsRegularityIndexTP.append(0)
                zCurrentFilamentsRegularityIndexTP.append(0)

            if len(wFilamentBranchPointsNEWCurrent) > 3 and qOptionBranchPoints == 1:
                vOverallStatNames = [' Regularity Index - BranchPoints']
                vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, zCurrentFilamentsRegularityIndexBP,
                                                        vOverallStatUnits, vOverallStatFactors,
                                                        vOverallStatFactorNames, vOverallStatIds)
            if len(wFilamentTerminalPointsNEWCurrent) > 3 and qOptionTerminalPoints == 1:
                vOverallStatNames = [' Regularity Index - TerminalPoints']
                vNewShollSpotsPerFilament.AddStatistics(vOverallStatNames, zCurrentFilamentsRegularityIndexTP,
                                                        vOverallStatUnits, vOverallStatFactors,
                                                        vOverallStatFactorNames, vOverallStatIds)

        #populated the Toruosity stat
        vNewStatTortuosityPerFilament.append(np.mean(np.array(vNewStatTortuosityPerSegment)[np.where(np.array(vNewStatTortuosityPerSegment)>0)]))

    ###############################################################################
    #Reset Spots for next filament
        wCompleteDendriteTimeIndex.extend([vFilamentsIndexT+1]*len(wSegmentIdsALL))
        wCompleteFilamentTimeIndex.extend([vFilamentsIndexT+1]*vFilamentCountActual)
        wCompeteSegmentBranchDepthPerFilament.append(vSegmentBranchDepthCurrent)

        vNewStatSpotNumberShollIntersections=[]
        vNewStatSpotShollDistance=[]
        vSpotPositionAllShollSpheresPerFilament=[]
        vNumberOfShollIntersectionPerSpherePerFilament=[]
    ###############################################################################
    ###############################################################################
        progress_bar2['value'] = int((aFilamentIndex+1)/vNumberOfFilaments*100) #  % out of 100
        qProgressBar.update()

    ###############################################################################
    #Add dendrite level statistics for each segment with length value
    vFilamentStatvIds=list(range(len(vAllFilamentDendriteLengthIds)))
    vFilamentStatUnits=['']*len(vAllFilamentDendriteLengthIds)

    if aVersionValue < 10:
        vFilamentStatFactors=(['Segment']*len(vAllFilamentDendriteLengthIds), [str(x) for x in wCompleteDendriteTimeIndex] )
    else:
        vFilamentStatFactors=(['Dendrite']*len(vAllFilamentDendriteLengthIds), [str(x) for x in wCompleteDendriteTimeIndex] )
    vFilamentStatFactorName=['Category','Time']
    ########################
    #Tortuosity
    vFilamentStatNames=[' Dendrite Tortuosity ']*(len(vAllFilamentDendriteLengthIds))
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteTortuosityPerSegment,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, wSegmentIdsALL)

    vNewStatCompleteTortuosityPerSegmentSumPerum=[vNewStatCompleteTortuosityPerSegmentSum[i] / vAllFilamentDendriteLength[i] for i in range(len(vAllFilamentDendriteLength))]
    vFilamentStatNames=[' Dendrite Tortuosity Sum ']*(len(vAllFilamentDendriteLengthIds))
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteTortuosityPerSegmentSum,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, wSegmentIdsALL)

    #########################
    #########################
    #Produce Report the Filament level stats
    vFilamentStatUnits=['']*vFilamentCountActual
    vFilamentStatFactors=(['Filament']*vFilamentCountActual, [str(x) for x in wCompleteFilamentTimeIndex] )
    vFilamentStatFactorName=['Category','Time']
    vFilamentStatNames=[' Filament - Tortuosity']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatTortuosityPerFilament,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)
    ########################
    #Mean distance to Terminal Point
    vFilamentStatNames=[' Filament - TerminalPoint Mean Distance to soma ']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteFilamentTerminalPointDistToSomaMean,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, vFilamentIds)
    ########################
    #Max distance to Terminal Point
    vFilamentStatNames=[' Filament - TerminalPoint Max Distance to soma ']*vFilamentCountActual
    vFilaments.AddStatistics(vFilamentStatNames, vNewStatCompleteFilamentTerminalPointDistToSomaMax,
                          vFilamentStatUnits, vFilamentStatFactors,
                          vFilamentStatFactorName, vFilamentIds)

    if qOptionConvexHull == 1:
        if vDataSize[2]==1:
            vFilamentStatNames=[' Filament Dendritic Field Area (convexhull)']*vFilamentCountActual
        else:
            vFilamentStatNames=[' Filament Dendritic Field Volume (convexhull)']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, wNewStatConvexHullVolumePerFilament,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)

        if vDataSize[2]==1:
            vFilamentStatNames=[' Filament Dendritic Field Perimeter (convexhull)']*vFilamentCountActual
        else:
            vFilamentStatNames=[' Filament Dendritic Field SurfaceArea (convexhull)']*vFilamentCountActual
        vFilaments.AddStatistics(vFilamentStatNames, wNewStatConvexHullAreaPerFilament,
                              vFilamentStatUnits, vFilamentStatFactors,
                              vFilamentStatFactorName, vFilamentIds)


    ###################################
    #Create Branch points for all filaments and create labels for branch point classification
    if qOptionBranchPoints == 1 and qOptionMergePoints == 1:
        #Create Spots for all Branch Points
        vNewSpotsBranchPointsPerFilamentComplete = vImarisApplication.GetFactory().CreateSpots()
        vNewSpotsBranchPointsPerFilamentComplete.Set(wFilamentBranchPointsComplete,
                              [vFilamentsIndexT]*len(wFilamentBranchPointsComplete),
                              [1]*len(wFilamentBranchPointsComplete))
        vNewSpotsBranchPointsPerFilamentComplete.SetName(' BranchPoints - ALL:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewSpotsBranchPointsPerFilamentComplete.SetColorRGBA(zRandomColor)#Set Random color
        vSpotFilamentPoints.AddChild(vNewSpotsBranchPointsPerFilamentComplete, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)
    ############
        #Add new stat to each branch point
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vSpotsvIds=list(range(len(wCompleteBranchPointsDistAlongFilamentStatALL)))
        vSpotsStatUnits=['um']*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vSpotsStatFactors=(['Spot']*len(wCompleteBranchPointsDistAlongFilamentStatALL), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        vSpotsStatNames=[' Distance to soma along dendrites']*len(wCompleteBranchPointsDistAlongFilamentStatALL)
        vNewSpotsBranchPointsPerFilamentComplete.AddStatistics(vSpotsStatNames, wCompleteBranchPointsDistAlongFilamentStatALL,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)


    ############
        #Create Labels for the branch points
        vLabelIndices=list(range(len(wFilamentBranchPointsComplete)))
        wLabelList=[]
        wLabelName = ('Arborization','Continuation', 'Termination')
        for i in range (3):
            wLabelList=[]
            for j in range (len(vLabelIndices)):
                if vNodeTypesComplete[j] == i:
                    vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                          'Classified Nodes',
                                                          'FilamentId-' + str(vNodeFilamentIdsComplete[j]) + '--' + str(wLabelName[vNodeTypesComplete[j]]))
                    wLabelList.append(vLabelCreate)
            vNewSpotsBranchPointsPerFilamentComplete.SetLabels(wLabelList)

        vNewSpotsBranchPointsPerFilamentComplete.SetLabels(wLabelListBranchPoints)


    if qOptionTerminalPoints == 1 and qOptionMergePoints == 1:
        vNewSpotsTerminalPointsPerFilamentComplete = vImarisApplication.GetFactory().CreateSpots()
        vNewSpotsTerminalPointsPerFilamentComplete.Set(wFilamentTerminalPointsComplete,
                              [vFilamentsIndexT]*len(wFilamentTerminalPointsComplete),
                              [1]*len(wFilamentTerminalPointsComplete))
        vNewSpotsTerminalPointsPerFilamentComplete.SetName(' TerminalPoints - ALL:'+ str(vFilamentIds[vFilamentCountActual-1]))
        zRandomColor=(random.uniform(0, 1) * 256 * 256 * 256 )
        vNewSpotsTerminalPointsPerFilamentComplete.SetColorRGBA(zRandomColor)#Set Random color
        vSpotFilamentPoints.AddChild(vNewSpotsTerminalPointsPerFilamentComplete, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSpotFilamentPoints, -1)

    ############
        #Add new stat to each terminal point
        vSpotsTimeIndex=[vFilamentsIndexT+1]*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vSpotsvIds=list(range(len(wCompleteTerminalPointsDistAlongFilamentStatALL)))
        vSpotsStatUnits=['um']*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vSpotsStatFactors=(['Spot']*len(wCompleteTerminalPointsDistAlongFilamentStatALL), [str(x) for x in vSpotsTimeIndex] )
        vSpotsStatFactorName=['Category','Time']
        vSpotsStatNames=[' Distance to soma along dendrites']*len(wCompleteTerminalPointsDistAlongFilamentStatALL)
        vNewSpotsTerminalPointsPerFilamentComplete.AddStatistics(vSpotsStatNames, wCompleteTerminalPointsDistAlongFilamentStatALL,
                                      vSpotsStatUnits, vSpotsStatFactors,
                                      vSpotsStatFactorName, vSpotsvIds)

    ############
    #Create Labels for the terminal points
        vNewSpotsTerminalPointsPerFilamentComplete.SetLabels(wLabelListTerminalPoints)



    #Sholl Branching Density
    #Make series of fixed (randomly placed lines/planes in the volume)
    #Quantify the number of Sholl Intersections with these lines
    #Report NumberIntersections/um

    #Alternative:  create convexhull around terminal points, make sure the lines
    # fall inside of the convex hull

    ###############################################################################



    ##############################################################################
    #Visibility of the Scene Objects
    # vSpotFilamentPoints.SetVisible(0)


    ##############################################################################
    #Add Convex Hull surfaces
    if qOptionConvexHull == 1:
        vSurfaceHull.SetName('Filament ConvexHull Surfaces')
        vSurfaceHull.SetColorRGBA(vFilaments.GetColorRGBA())

        # #Add new surface convex hull folder
        vSurfaceConvexHull.AddChild(vSurfaceHull, -1)
        vImarisApplication.GetSurpassScene().AddChild(vSurfaceConvexHull, -1)

        #Create Labels for Convex hull surfaces to match filament ID
        vLabelIndices=list(range(vFilamentCountActual))
        wLabelList=[]
        for j in range (len(vLabelIndices)):
            vLabelCreate = vFactory.CreateObjectLabel(vLabelIndices[j],
                                                      'FilamentIds',
                                                      str(vFilamentIds[j]))
            wLabelList.append(vLabelCreate)
        vSurfaceHull.SetLabels(wLabelList)


    ################
    #Add Surface labels for ConvexHull with FilamentID as name
    #NEED to do this



    ##############################################################################
    vFilaments.SetName(vFilaments.GetName()+' -- Analyzed')
    vImarisApplication.GetSurpassScene().AddChild(vFilaments, -1)

    qProgressBar.destroy()
    qProgressBar.mainloop()